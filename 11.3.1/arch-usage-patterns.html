<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>WiredTiger: Usage Patterns</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="sorttable.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="wiredtiger.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://wiredtiger.com/"><img alt="Logo" src="LogoFinal-header.png" alt="WiredTiger" /></a></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Version 11.3.1</span>
   </div>
   <div id="projectbrief"><!-- 11.3.1 --></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<div class="banner">
  <a href="https://github.com/wiredtiger/wiredtiger">Fork me on GitHub</a>
  <a class="last" href="http://groups.google.com/group/wiredtiger-users">Join my user group</a>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('arch-usage-patterns.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Usage Patterns </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><b>Caution: the Architecture Guide is not updated in lockstep with the code base and is not necessarily correct or complete for any specific release.</b></p>
<p>WiredTiger is a highly multi-threaded application which means that a large number of operations can happen in parallel. In order to be performant WiredTiger utilizes a number of lock-free programming mechanisms. Commonly used patterns are documented here. A pattern in this instance is a combination of one or more lock-free programming techniques.</p>
<p>This architecture guide page aims to aid developers in understanding and using these patterns in the future.</p>
<h1><a class="anchor" id="message-passing"></a>
Message passing with acquire and release</h1>
<p>When a writer thread needs to share data with one or more reader threads concurrently the message passing pattern can be used. For this pattern to work two variables are required. A "payload" which is the data being shared, and a "signal" variable. The payload could be a number of things, e.g:</p>
<ul>
<li>A struct with any number of fields</li>
<li>A single variable in memory</li>
</ul>
<p>For the writer to share this payload with readers it needs to perform two steps in the correct order. Firstly it writes the payload, then writes a signal variable with a release write. The reader threads will read the signal variable to know if the payload is safe to read. The release write must use the <code>WT_RELEASE_WRITE</code> macro described in <a class="el" href="arch-concurrency.html#rel-marked">Release</a>.</p>
<p>The reader threads must read with the opposite order, to do so they read the signal variable using the acquire read macro <code>WT_ACQUIRE_READ</code>. Then they read the payload, the <code>WT_ACQUIRE_READ</code> macro provides the required ordering semantics. The macro is described in <a class="el" href="arch-concurrency.html#acq-marked">Acquire</a>. If the signal variable indicates the payload is safe to read the reader thread can read the payload.</p>
<p>This pattern is used in many places in WiredTiger but they are not listed here as the list will become stale.</p>
<p><b> Example pseudocode: </b> </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> write {</div>
<div class="line">    s-&gt;payload = 5;</div>
<div class="line">    WT_RELEASE_WRITE(s-&gt;ready, <span class="keyword">true</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> read {</div>
<div class="line">    <span class="keywordtype">bool</span> ready;</div>
<div class="line"> </div>
<div class="line">    WT_ACQUIRE_READ(ready, s-&gt;ready);</div>
<div class="line">    <span class="keywordflow">if</span> (ready) {</div>
<div class="line">        var = s-&gt;payload;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="slotted-arrays"></a>
Slotted arrays</h1>
<h2><a class="anchor" id="slotted-arrays-overview"></a>
Overview</h2>
<p>Given an array of size <code>Z</code>, where objects within the array may be unused. The slot counter pattern provides a variable - whose name varies depending on implementation but we will refer to it as <code>slot_count</code> - to readers to determine how many slots in that array need reviewing. That way the reader only has to walk <code>slot_count</code> slots in the array instead of traversing the whole list. This allows for dynamic array growth and provides an optimization as readers would otherwise have to walk the full array.</p>
<p>If the array size is fixed then <b>no</b> ordering is defined for <code>slot_count</code>. If the array is allowed to grow then additional ordering is defined for <code>slot_count</code>. See <a class="el" href="arch-usage-patterns.html#growable-arrays">Growable arrays</a> for further details.</p>
<h3><a class="anchor" id="slotted-arrays-use-cases"></a>
Use cases</h3>
<p>This pattern should only be used if performance is critical in the read path, prior to usage of this pattern the following determinations should be made:</p><ul>
<li>Is walking the entire array too expensive?</li>
<li>Is a read-write lock protecting both traversing and writing to the array too expensive?</li>
<li>Does this array need to be growable?</li>
</ul>
<h3><a class="anchor" id="slotted-arrays-writing"></a>
Writing</h3>
<p>When an algorithm initializes an object in the array there are two outcomes with respect to <code>slot_count:</code> </p><ol type="1">
<li>If a free slot is available at an index smaller than <code>slot_count</code> the slot will be used and the object in the slot will be initialized.</li>
<li>If there is no free slot available at a position less than <code>slot_count</code> then the slot at index <code>slot_count</code> is used and <code>slot_count</code> is incremented.</li>
</ol>
<p>Additionally the writers must follow the <a class="el" href="arch-usage-patterns.html#message-passing">Message passing with acquire and release</a> pattern when initializing the slot. Firstly the object / slot must be initialized with its payload then a flag or pointer can be set for readers to safely read the object held in the slot itself.</p>
<h3><a class="anchor" id="slotted-arrays-reading"></a>
Reading</h3>
<p>Reading from this array requires readers to loop through the array, up until <code>slot_count</code>. Readers must read <code>slot_count</code> <b>only once</b> prior to entering the body of the loop and ensure a local copy of the value is used for the remainder of the loop.</p>
<p>When reading a specific slot, readers must follow the <a class="el" href="arch-usage-patterns.html#message-passing">Message passing with acquire and release</a> pattern by reading a flag or pointer indicating the slot is initialized prior to reading the contents of the object held in the slot.</p>
<h3><a class="anchor" id="slotted-arrays-correctness"></a>
Correctness of allowing reading while allowing writes</h3>
<p>Additional writes to the array can occur concurrently, and as a copy of <code>slot_count</code> is taken by readers prior to their traversal they may miss objects being initialized concurrently. The reader algorithm must take care to ensure that once it has entered the loop new slots being used in the array will not impact the outcome of the loop as it is not guaranteed to see those.</p>
<h2><a class="anchor" id="growable-arrays"></a>
Growable arrays</h2>
<p>A growable array is one where the value of <code>Z</code> is not fixed and the user can increase the array size while the array is in use. Here we will discuss the additional semantics required to support a growable array.</p>
<p><b>Note:</b> <a class="el" href="arch-concurrency.html#generations">Generations</a> handle the life cycle, creation and freeing of the growable array and that will not be covered here.</p>
<h3><a class="anchor" id="growable-arrays-writing"></a>
Writing</h3>
<p>If a new slot is required in the array, but all slots are in use and <code>slot_count</code> is equal to the size <code>Z</code> of the array then the array must grow. The variable <code>slot_count</code> has additional ordering defined when swapping in the array. The array pointer swap must happen before <code>slot_count</code> is incremented. This requires a <a class="el" href="arch-concurrency.html#rel-marked">Release</a>.</p>
<h3><a class="anchor" id="growable-arrays-reading"></a>
Reading</h3>
<p>Readers must respect the writer side ordering. The <code>slot_count</code> must be read prior to reading the array pointer. This requires an <a class="el" href="arch-concurrency.html#acq-marked">Acquire</a>. If this ordering is not respected the reader could read an old array pointer but a new <code>slot_count</code> and encounter an array index out of bounds exception.</p>
<h3><a class="anchor" id="growable-arrays-further-details"></a>
Further details</h3>
<p>The fixed size version of this pattern is used to maintain the <a class="el" href="arch-connection.html">Connection</a>'s sessions array. The dynamically growing version of this pattern is used to maintain the hazard pointer array for a <a class="el" href="arch-session.html">Session</a>.</p>
<h1><a class="anchor" id="write-while-stable"></a>
Write While stable (WwS)</h1>
<p>The Write while Stable (WwS) pattern performs a write to a memory location <code>W</code>, but only considers that write to be successful if the value of a <em>separate</em> memory location <code>S</code> has not changed by the time the write to <code>W</code> has become visible. As a result when the <code>WwS</code> pattern succeeds, the next time the value of <code>S</code> changes all threads can already see the update to <code>W</code>.</p>
<p>In this pattern the write to <code>W</code> always takes place, however the writing thread will not consider the update to be valid until it has verified that <code>S</code> is unchanged. The writing thread is responsible for either retrying or rolling back the write to <code>W</code> on a failure. Threads reading from <code>W</code> must be able to handle or ignore these interim "failed" writes to <code>W</code>, and must perform a read-acquire on <code>S</code> before reading <code>W</code>.</p>
<p><img src="WwS.png" alt="" style="transform: scale(0.75,0.75);" class="inline"/></p>
<p>This pattern should only be used in performance critical paths. In all other cases a lock should be used as it provides a much simpler interface for developers when reading and debugging code.</p>
<h2><a class="anchor" id="write-while-stable-pseudocode"></a>
Pseudocode</h2>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> example_WwS(<span class="keywordtype">int</span> *W, <span class="keywordtype">int</span> *S) {</div>
<div class="line">    <span class="comment">// The initial read from S must take place before the write to W.</span></div>
<div class="line">    WT_ACQUIRE_READ(initial_s_value, *S);</div>
<div class="line">    *W = new_value;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// This full barrier ensures the write to W is visible to other threads *before*</span></div>
<div class="line">    <span class="comment">// we re-read the contents of S to verify it hasn&#39;t changed.</span></div>
<div class="line">    FULL_BARRIER();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span>(*S != initial_s) {</div>
<div class="line">        <span class="comment">// The write was unsuccessful. Rollback or retry.</span></div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="write-while-stable-wt-implementation"></a>
Example WT implementation</h2>
<p><b>Note:</b> The following example assumes familiarity with WiredTiger's <a class="el" href="arch-concurrency.html#generations">Generations</a>.</p>
<p>In the generation code the <code>__wt_session_gen_enter</code> function the current value of the <code>connection-&gt;generation</code> (<code>S</code>) and writes it to <code>session-&gt;generation</code> (<code>W</code>). Independently a second thread executing <code>__gen_oldest</code> will first read <code>connection-&gt;generation</code> and then walk all <code>session-&gt;generations</code>, reporting the smallest generation seen.</p>
<p>Without this pattern <code>__wt_session_gen_enter</code> could enter a generation <code>G</code>, the <code>connection-&gt;generation</code> could be advanced to <code>G+1</code>, and the <code>__gen_oldest</code> thread would see the update to <code>connection-&gt;generation</code> <code>G+1</code> but not the write to the <code>session-&gt;generation</code> <code>G</code>. This would incorrectly report the oldest generation as <code>G+1</code> while the <code>session-&gt;generation</code> <code>G</code> is still active.</p>
<p>On a successful <code>WwS</code> the write to <code>session-&gt;generation</code> must be visible before advancing the <code>connection-&gt;generation</code>. If the <code>connection-&gt;generation</code> has not been advanced the new <code>session-&gt;generation</code> is visible and the oldest generation will be equal to it.</p>
<p>On a failed <code>WwS</code> <code>__wt_session_gen_enter</code> must retry and enter the new generation <code>G+1</code>. If <code>__gen_oldest</code> sees the "invalid" <code>session-&gt;generation</code> of <code>G</code> it will report an older generation that the actual oldest generation. This is considered acceptable as it temporarily delays freeing a resource which has no impact on correctness.</p>
<p>This is the trimmed down version of the writing thread code in the generations logic: </p><div class="fragment"><div class="line"><span class="keywordflow">do</span> {</div>
<div class="line">    session-&gt;generations[which] = __wt_gen(session, which);</div>
<div class="line">    WT_FULL_BARRIER();</div>
<div class="line">} <span class="keywordflow">while</span> (session-&gt;generations[which] != __wt_gen(session, which));</div>
</div><!-- fragment --><h1><a class="anchor" id="win-the-race"></a>
Win the Race</h1>
<p><b>Note:</b> This usage pattern behaves like a lightweight version of a trylock. In non-critical code paths a trylock should be preferred as it also provides acquire/release semantics around the critical section, guaranteeing instructions inside the critical section take place within the lock.</p>
<p>Multiple threads will often compete to enter a critical section or execute functions that should be limited to a single thread. For example in <code>__wt_cache_pool_server</code> all threads will attempt to become the pool manager but only one manager is allowed. Whichever thread comes first will become the manager.</p>
<p>To implement this usage pattern all threads attempt to set some shared flag <code>F</code> via a <code>compare_and_swap</code>. On success the winning thread is allowed to continue into the critical section. When the thread leaves the critical section it unsets the flag for the other threads to claim. Threads that fail to claim the flag <code>F</code> must decide whether to continue, abort or retry.</p>
<h2><a class="anchor" id="win-the-race-example"></a>
Example</h2>
<p>In <code>__wt_cache_pool_server</code> all threads attempt to set the <code>pool_managed</code> flag with a call to <code>__wt_atomic_cas8</code>(&amp;cp-&gt;pool_managed, 0, 1) and only the successful thread is allowed then to set the <code>WT_CACHE_POOL_MANAGER</code> flag and perform the duties of the pool manager.</p>
<h2><a class="anchor" id="win-the-race-pseudocode"></a>
Example Pseudocode</h2>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> win_the_race(<span class="keywordtype">int</span> *F) {</div>
<div class="line">    <span class="keywordflow">if</span>(__wt_atomic_int(&amp;F, 0, 1)) {</div>
<div class="line">        <span class="comment">// perform work that must be performed by a single thread</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// unset the flag at the end of the section</span></div>
<div class="line">          *F = 0;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">Reference Guide</a></li><li class="navelem"><a class="el" href="arch-index.html">WiredTiger Architecture Guide</a></li><li class="navelem"><a class="el" href="arch-toc-int-wt-dev.html">Internal WiredTiger Development</a></li>
    <li class="footer">Copyright (c) 2008-present MongoDB, Inc.  All rights reserved.  Contact <a href="mailto:info@wiredtiger.com">info@wiredtiger.com</a> for more information.</li>
  </ul>
</div>
</body>
</html>
