<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>WiredTiger: Deleted Pages and Fast-Truncate</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="sorttable.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="wiredtiger.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://wiredtiger.com/"><img alt="Logo" src="LogoFinal-header.png" alt="WiredTiger" /></a></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Version 11.1.0</span>
   </div>
   <div id="projectbrief"><!-- 11.1.0 --></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<div class="banner">
  <a href="https://github.com/wiredtiger/wiredtiger">Fork me on GitHub</a>
  <a class="last" href="http://groups.google.com/group/wiredtiger-users">Join my user group</a>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('arch-fast-truncate.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Deleted Pages and Fast-Truncate </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><div class="arch_head"><table class="doxtable">
<tr>
<th rowspan="2" style="width:10%;"> <div><a href="arch-index.html"><img class="arch_thumbnail" src="wt_diagram.png" usemap="#wt_diagram_map" style="background-image: url(wt_diagram.png)"></a></div></th><th style="width:44%">Data Structures</th><th style="width:45%">Source Location</th></tr>
<map id="wt_diagram_map" name="wt_diagram_map">
<area shape="rect" id="id1" href="modules.html" title="modules.html" alt="" coords="248,128,283,144"/>
<area shape="rect" id="id2" href="arch-cache.html" title="arch-cache.html" alt="" coords="204,546,248,562"/>
<area shape="rect" id="id3" href="arch-cursor.html" title="arch-cursor.html" alt="" coords="234,224,280,240"/>
<area shape="rect" id="id4" href="arch-eviction.html" title="arch-eviction.html" alt="" coords="303,546,356,562"/>
<area shape="rect" id="id5" href="arch-logging.html" title="arch-logging.html" alt="" coords="388,650,443,666"/>
<area shape="rect" id="id6" href="arch-schema.html" title="arch-schema.html" alt="" coords="123,224,179,240"/>
<area shape="rect" id="id7" href="command_line.html" title="command_line.html" alt="" coords="374,23,430,39"/>
<area shape="rect" id="id8" href="arch-log-file.html" title="arch-log-file.html" alt="" coords="308,865,339,897"/>
<area shape="rect" id="id9" href="arch-metadata.html" title="arch-metadata.html" alt="" coords="25,328,89,344"/>
<area shape="rect" id="id10" href="arch-python.html" title="arch-python.html" alt="" coords="84,23,157,39"/>
<area shape="rect" id="id11" href="arch-snapshot.html" title="arch-snapshot.html" alt="" coords="297,441,371,457"/>
<area shape="rect" id="id12" href="arch-transaction.html" title="arch-transaction.html" alt="" coords="298,328,387,344"/>
<area shape="rect" id="id13" href="arch-hs.html" title="arch-hs.html" alt="" coords="93,642,140,674"/>
<area shape="rect" id="id14" href="arch-block.html" title="arch-block.html" alt="" coords="196,642,256,674"/>
<area shape="rect" id="id15" href="arch-dhandle.html" title="arch-dhandle.html" alt="" coords="144,320,205,352"/>
<area shape="rect" id="id16" href="arch-data-file.html" title="arch-data-file.html" alt="" coords="179,865,245,897"/>
<area shape="rect" id="id17" href="arch-row-column.html" title="arch-row-column.html" alt="" coords="117,433,205,465"/>
<area shape="rect" id="id18" href="arch-fs-os.html" title="arch-fs-os.html" alt="" coords="175,755,357,771"/>
</map>
<tr>
<td><code><code>WT_PAGE_DELETED</code></code></td><td><code><code>src/btree/bt_delete.c</code></code></td></tr>
</table>
</div><p> <b>Caution: the Architecture Guide is not updated in lockstep with the code base and is not necessarily correct or complete for any specific release.</b></p>
<p>WiredTiger includes a scheme for discarding whole pages at a time. This is known as <em>fast-truncate</em> or <em>fast-delete</em> (the terms are used interchangeably) and the pages it is done to are called <em>deleted pages</em>.</p>
<p>There are also four other ways deleted pages can appear in a database. The checkpoint cleanup code (found in <code>bt_sync.c</code>) discards pages it finds to contain only obsolete values. Pages that reconcile completely empty turn into deleted pages. In VLCS, an empty deleted page is inserted when loading an internal page whose start recno is less than the start recno of its first child. Finally, new trees are created with a single empty deleted leaf page. These circumstances are all discussed further below.</p>
<p>The fast-truncate and deleted-page arrangements to some extent violate the system architecture and the system's layering and modularity. Consequently they have tentacles in a number of places; furthermore, a lot of the functioning is implicit or hidden and appears magic to the uninitiated.</p>
<p>Ideally, this page documents all the tentacles (see <a class="el" href="arch-fast-truncate.html#ft_pointers">Pointers to pieces of the implementation</a>) and explains all the implicit magic.</p>
<p>Most of the code related to fast-truncate and deleted pages lives in <code>bt_delete.c</code>.</p>
<h1><a class="anchor" id="ft_deleted_pages"></a>
Deleted Pages</h1>
<p>One of the states a <code>WT_REF</code> can be in is <code>WT_REF_DELETED</code>. This means that (as of some point) all data on the page has been removed. However, it is not necessarily the case that this is true for all current or possible readers. The <code>page_del</code> field of a <code>WT_REF</code>, if not <code>NULL</code>, contains information about the transaction that deleted the page. Its type is <code>WT_PAGE_DELETED</code>. It can be thought of as a special kind of update, and contains roughly the same information.</p>
<p>The <code>page_del</code> field can be <code>NULL</code>; this means that the prior data on the page is all obsolete and nobody can see it. (Or equivalently, the deletion has become globally visible.) If non-null, the transaction and timestamp information describes the visibility of the deletion. When the deletion is not visible, the prior data on the page is (or may be) and may still need to be read. Reading a deleted page into memory requires deleting every item on it with its own <code>WT_UPDATE</code>; the process of doing this is called <em>instantiation</em> and is described below under <a class="el" href="arch-fast-truncate.html#ft_instantiation">Instantiation</a>.</p>
<p>When a page is deleted by fast-truncate, a <code>WT_PAGE_DELETED</code> structure is allocated, populated with information about the transaction containing the truncate, and inserted in the <code>page_del</code> field. When a page is discarded by checkpoint cleanup or other mechanisms that have already determined that all the prior data is obsolete, the <code>page_del</code> field is left <code>NULL</code>.</p>
<p>Accessing the deletion information requires locking the <code>WT_REF</code>. This both prevents the structure from being discarded while under examination and prevents the page from being simultaneously instantiated by another thread. (While the <code>page_del</code> field can be tested for <code>NULL</code> atomically, this has limited utility.)</p>
<p>In general the deletion information should only be consulted if the ref's state prior to locking was <code>WT_REF_DELETED</code>. Apart from instantiated pages, whose state is <code>WT_REF_MEM</code> (see <a class="el" href="arch-fast-truncate.html#ft_instantiated_pages">Instantiated Pages</a> below) the <code>page_del</code> field will be <code>NULL</code>.</p>
<p>Because locking the ref is expensive, and visibility checks are expensive as well, we want to avoid doing either unnecessarily. Consequently many of the places in the system that lock the ref to examine the deletion information will discard it right away if they find the deletion has become globally visible.</p>
<p>Note that because on-disk pages can only be discarded at certain points, a page with null <code>page_del</code> may still have an on-disk page and consequently an address. That page presumptively contains no useful information. (A page with non-null <code>page_del</code> should always have an on-disk page.)</p>
<p>The transaction referenced in the deletion information may be committed or uncommitted, but it is never aborted. Upon transaction rollback the <code>page_del</code> field is cleared immediately.</p>
<p>Note that it is not possible to delete a page twice; if the same region of a tree is truncated twice, the already-deleted pages will be skipped over the second time. See <a class="el" href="arch-fast-truncate.html#ft_truncate">Truncation</a>.</p>
<p>Also note that deleted pages still "exist" in the sense that the <code>WT_REF</code> remains, and searches that lead to its portion of the namespace will still land on it. (This triggers instantiation.) At some point after the deletion becomes globally visible, the <code>WT_REF</code> is discarded. This happens either during an internal page split or reverse split, or when the internal page is evicted. It is this discard process (rather than the deletion itself) that creates gaps in the namespace.</p>
<h1><a class="anchor" id="ft_instantiated_pages"></a>
Instantiated Pages</h1>
<p>An instantiated page is a page in <code>WT_REF_MEM</code> state that has been produced by the instantiation process (see <a class="el" href="arch-fast-truncate.html#ft_instantiation">Instantiation</a>). For most purposes instantiated pages are ordinary in-memory pages.</p>
<p>Instantiated pages always have a modify structure, and differ from ordinary in-memory pages in two ways. First, the field <code>page-&gt;modify-&gt;instantiated</code> is set to <code>true</code>, and the <code>page_del</code> field is retained from the prior deleted state. Second, if the transaction that deleted the page had not resolved yet when the instantiation happened, the field <code>page-&gt;modify-&gt;inst_updates</code> contains an array of the <code>WT_UPDATE</code> structures used to do the instantiation.</p>
<p>These two conditions are orthogonal and resolve independently; when both are resolved the page is thenceforth a completely normal in-memory page.</p>
<p>Note that instantiated pages are not automatically marked dirty. (See the notes on this point in the <a class="el" href="arch-fast-truncate.html#ft_instantiation">Instantiation</a> section.)</p>
<p>Also note that it is not possible to fast-truncate an instantiated page. Only on-disk pages can be fast-truncated. See <a class="el" href="arch-fast-truncate.html#ft_truncate">Truncation</a>.</p>
<h2><a class="anchor" id="ft_instantiated_instantiated"></a>
The instantiated flag and the page_del field</h2>
<p>The <code>instantiated</code> flag and the <code>page_del</code> structure are retained for the benefit of parent internal page reconciliation. See <a class="el" href="arch-fast-truncate.html#ft_internal_reconciliation">Internal page reconciliation</a> below.</p>
<p>When the page is itself reconciled, or if the transaction that deleted it rolls back, the <code>instantiated</code> flag is cleared and the <code>page_del</code> structure is discarded.</p>
<p>Note that the <code>page_del</code> field of an instantiated page should not be used to make operational decisions. Additional updates might have been applied to the page since the instantiation happened; these may contradict or obsolete the deletion information.</p>
<h2><a class="anchor" id="ft_instantiated_updates"></a>
The inst_updates field</h2>
<p>Meanwhile, the <code>inst_updates</code> field is kept independently until the transaction that created it is resolved. It in effect belongs to that transaction and is neither needed nor used by anything else, with one exception: eviction checks whether it is non-NULL before evicting the page. (Pages with an instantiated but uncommitted truncate cannot be evicted.)</p>
<p>Because it is possible for the page to split between instantiation and transaction resolution, finding the updates created during instantiation to resolve them is problematic. The <code>inst_updates</code> field makes this possible.</p>
<p>Upon resolution (either commit or rollback) the <code>inst_updates</code> field is discarded.</p>
<h1><a class="anchor" id="ft_instantiation"></a>
Instantiation</h1>
<p>Instantiation is the process by which an on-disk deleted page (ref in state <code>WT_REF_DELETED</code>) is converted into an in-memory page (ref in state <code>WT_REF_MEM</code>) with all its items explicitly deleted with tombstone updates. <em>Semantically, this is an identity transformation.</em></p>
<p>This occurs under two sets of circumstances: first, if a thread that cannot yet see the deletion tries to read from the deleted page; and second, if a search lands on the deleted page's portion of the namespace. It can happen either before or after the transaction that deleted the page is resolved. (But not at the same time; locking the ref prevents that.)</p>
<p>Note that for searches that are positioning to do updates, the instantiation is unavoidable; however, for searches that are only reading, it would be better to return <code>WT_NOTFOUND</code> without pointlessly instantiating the page. This is not currently implemented and as of this writing it is not entirely clear how involved or feasible such changes would be. Also note that this only applies to explicit searches and searches that are part of other cursor operations; the cursor next and previous operations do skip over deleted pages.</p>
<p>In any case, we notice the page is deleted when we read it. If the page has no address, or it has an address but the deletion is globally visible, we create a new in-memory page instead of reading the on-disk page. Otherwise, we read the on-disk page and call the instantiation code in <code>bt_delete.c</code>.</p>
<p>The instantiation code iterates the page and adds a tombstone for every item. (To be precise, it adds a tombstone for every item that isn't already deleted; items that have a stop time do not need to be deleted again.) The row-store version of this iterates the entries on the page and directly adds a tombstone to each update list. The column-store version uses a cursor and calls into <code>col_modify.c</code> to do it; this is because the data structures are considerably more complicated and updating them directly would require a lot of cut-and-paste code.</p>
<p>The tombstones are tagged with <code>WT_UPDATE_RESTORED_FAST_TRUNCATE</code>. This is used by <code>__wt_txn_prepare</code> to avoid trying to coalesce these updates with others to the same key. (That wouldn't work because the instantiation updates don't appear directly in the transaction modify list; they are referenced indirectly through the truncation.)</p>
<p>If the deletion is not resolved (according to the <code>page_del</code> information in the ref) an array is allocated to hold the updates and this is placed in <code>page-&gt;modify-&gt;inst_updates</code>. As noted above this is used to find the updates during transaction resolution.</p>
<p>Finally, <code>page-&gt;modify-&gt;instantiated</code> is set to <code>true</code>.</p>
<p>The instantiated page is not automatically marked dirty. Instantiation is logically an identity transformation; if the page is not otherwise modified, discarding it after instantiation returns it to the <code>WT_REF_DELETED</code> state, and the deletion information remains in the ref. (If the parent page is then evicted, the deletion information is written into the address cell. If it is discarded because it is also unmodified, the deletion information must have already been written to disk and can be read in again later.)</p>
<p>However, VLCS pages end up marked dirty anyway because the instantiation logic uses <code>col_modify</code> to post the tombstones and that always marks its page dirty.</p>
<p>Note that in three cases the instantiation code is skipped: verify, salvage, and upgrade are concerned only with the on-disk state. These cases also skip the optimization that generates blank pages instead of reading pages that contain only obsolete values (those with a globally visible truncation) &ndash; verify is, at least in part, concerned with the physical structure of the tree and this substitution can confuse it. Salvage and upgrade are included for consistency, and also because in salvage the internal page with the deletion information is not necessarily available (or correct) and it is probably better to not try to use it.</p>
<h1><a class="anchor" id="ft_internal_reconciliation"></a>
Internal page reconciliation</h1>
<p>Reconciliation of internal pages that have deleted (or instantiated) children requires special handling. It is necessary to check whether the page can be dropped entirely, and if not, to write the deletion information into the child page's address cell. (Like the address of a ref, the deletion information more or less belongs to the parent; it is written to disk as part of the parent page, not the child page.) See <a class="el" href="arch-fast-truncate.html#ft_on_disk_format">On-disk format</a>.</p>
<p>The code that supports this lives in <code>rec_child.c</code> and is used by both VLCS and row-store internal page reconciliation.</p>
<p>If the child page is deleted (that is, the state is <code>WT_REF_DELETED</code>) we must lock the ref to examine the deletion information. Then there are several possible cases.</p>
<p>If the deletion is or has become globally visible, we can delete any on-disk block, and drop the child from the on-disk representation of the parent. This is accomplished by sending back <code>WT_CHILD_IGNORE</code>.</p>
<p>If the deletion is visible to the thread doing the reconciliation but not globally visible, we need to write the deletion information to disk. This is accomplished by sending back <code>WT_CHILD_PROXY</code> and copying the deletion information for the caller. (The "proxy" refers to a "proxy cell", which is another name for the deleted-address cells used to refer to deleted pages. This terminology is probably outdated and should perhaps be removed sometime.)</p>
<p>If the deletion is not visible to the thread doing the reconciliation, then we need to refer to the original on-disk page <em>without</em> the deletion information. This is accomplished by sending back <code>WT_CHILD_ORIGINAL</code>. This also requires leaving the parent page dirty. For checkpoints, <code>r-&gt;leave_dirty</code> is set; for eviction, that doesn't work, but there's also not much to be gained by evicting the page under these circumstances so instead we just fail.</p>
<p>For instantiated pages, under normal circumstances the instantiated child will be reconciled before its parent. Eviction skips parents that have in-memory children, and when checkpointing ordinarily all children are written out before their parents. In this case the instantiated flag and deletion information will have been cleared and no special steps are required to reconcile the parent. (It is possible for the truncation to be uncommitted so the update list to be non-null; however, this does not matter when checkpointing either the child or the parent, as the updates created by instantiation will be left in memory in the usual way. Eviction of the child is blocked in these circumstances.)</p>
<p>The only case when special steps are needed is when the parent is being checkpointed, and the child has been instantiated after the point in the tree walk that would have reconciled it. This gives us a child with no reconciliation result that we cannot refer to in the on-disk parent page. Fortunately in this case it must be correct to refer to the original pre-instantiation on-disk page: any changes to the instantiated page cannot be visible to the checkpoint and do not need to be part of it. However, we may need to write out the deletion information along with the address. This is the reason the deletion information is kept after instantiation. It turns out that the set of cases is exactly the same as the set of cases for deleted pages and the code can be shared, though it is necessary to lock the ref before calling it.</p>
<p>Note that in all these cases "visible" and "globally visible" do not include prepared transactions. Truncations that have been prepared but not yet committed cannot be written to disk (the on-disk format doesn't have space to represent the state) so must be treated as invisible during reconciliation. (And it turns out they must always be considered invisible; see <a class="el" href="arch-fast-truncate.html#ft_visibility">Notes on visibility</a>.)</p>
<h1><a class="anchor" id="ft_leaf_reconciliation"></a>
Leaf (child) reconciliation</h1>
<p>Deleted pages are already on disk and inherently never themselves need to be reconciled. Instantiated pages that have been read into memory, however, do.</p>
<p>Eviction of instantiated pages where the truncation is unresolved is blocked. In principle these pages could successfully go through update-restore eviction, but there are complications involved in doing so (e.g. handling the update list, and if the page were to split the <code>page_del</code> information would have to be cloned, and that requires locking) and it was judged not worthwhile.</p>
<p>Eviction of instantiated pages where the truncation is committed is permitted, however, and checkpoint of instantiated pages is always allowed. The first reconciliation after instantiation clears the instantiated flag (<code>page-&gt;modify-&gt;instantiated</code>) and discards the <code>page_del</code> structure, as once a reconciliation result exists it can be used to reconcile the parent. (This is true whether or not it includes the tombstones from instantiation, i.e., whether the truncation was committed.)</p>
<p>Note that "unresolved" includes "prepared". While we cannot write out a prepared truncation in the parent page's address cells, in principle after instantiation we could write out the prepared tombstone updates like any other prepared updates, and after doing so nothing special is needed in the parent. This is not currently done, chiefly because safely determining whether the truncation is prepared at the point where eviction needs to check is problematic. (We can't check <code>page_del</code> because it might have been discarded by then; looking in <code>inst_updates</code> is at best messy and it isn't entirely clear what locking or synchronization might be needed. Some such check, or an extra flag in the modify structure, is probably possible if it eventually becomes important to allow these evictions.)</p>
<h1><a class="anchor" id="ft_on_disk_format"></a>
On-disk format</h1>
<p>Deleted pages are referred to on disk by a special address cell type, <code>WT_CELL_ADDR_DEL</code>. These contain three additional packed integers between the time aggregate and the cell data: the transaction ID, commit timestamp, and durable timestamp of the transaction that deleted the page. (Only committed truncations are written out. Prepared truncations cannot be represented on disk. Truncations that are globally visible do not result in a cell in the parent page at all.)</p>
<p>These fields are, however, only present if the page header includes the <code>WT_PAGE_FT_UPDATE</code> flag, whose value is 0x20. Proper support for timestamped fast-truncate only appeared in WT 11.0; earlier versions neither write these fields nor expect to find them. The explicit header flag is required to make compatibility guarantees function as needed. (MongoDB 6.x knows how to read pages with <code>WT_PAGE_FT_UPDATE</code> set, but does not write them. This is controlled in the WT library by the <code>__wt_process::fast_truncate_2022</code> flag, whose default setting is controlled by the build config.)</p>
<h1><a class="anchor" id="ft_truncate"></a>
Truncation</h1>
<p>The B-tree cursor truncate code, found in <code>bt_cursor.c</code>, iterates through the specified truncation range with <code>cursor_next</code>, individually removing all values it finds. This is the slow-truncate path.</p>
<p>The fast-truncate functionality is implicit. Passing <code>true</code> for the <code>truncating</code> argument of <code>__wt_btcur_next</code> causes the flag <code>WT_READ_TRUNCATE</code> to be passed to the tree-walk inside the next code. Fast-truncate then happens inside the tree-walk code (in <code>bt_walk.c</code>) which calls <code>__wt_delete_page</code> on leaf pages it visits.</p>
<p>This function, in <code>bt_delete.c</code>, checks the page for eligibility. First, if the page is unmodified and in memory we attempt to evict it. Then we check if the page is on disk, that is, the state is <code>WT_REF_DISK</code>, and if so lock the ref. (And then check if it is <em>still</em> on disk.)</p>
<p>Then the following categories of pages are ineligible for fast-truncate:</p><ul>
<li>Pages that have no address. These should not exist, but we need to look at the address information and are therefore obliged to check.</li>
<li>Pages that may have overflow items. (Or internal pages.) Pages with overflow items need their overflow pages deleted as well, and that requires reading them into memory. The address cell type must be <code>WT_ADDR_LEAF_NO</code>, rather than <code>WT_ADDR_LEAF</code>, where overflow items may exist.</li>
<li>Pages that contain prepared values.</li>
<li>Pages where the newest transaction on the page (by either transaction ID or timestamp) is not visible.</li>
</ul>
<p>If the page passes these checks, we mark its parent dirty, initialize the <code>page_del</code> structure, add a <code>WT_TXN_OP_REF_DELETE</code> operation to the current transaction (except if we're truncating the history store, which is non-transactional), and set the ref state to <code>WT_REF_DELETED</code>.</p>
<p>Otherwise we report back to the tree-walk code that we couldn't delete the page and it needs to visit it. (This happens by a return flag and not by returning an error.)</p>
<p>Note that it is not possible to fast-truncate an already deleted page; ordinarily the tree-walk code will have already skipped over it (see <a class="el" href="arch-fast-truncate.html#ft_page_skip">Skipping deleted pages</a>) and also, <code>__wt_delete_page</code> won't accept one. If one truncate reaches a page truncated by another transaction that is not yet visible, such that the skip code doesn't skip it, we need to load the page, instantiate it, and attempt to slow-truncate it; this will discover the transaction conflict.</p>
<p>Also note that the first and last pages of a truncate operation are always slow-truncated regardless of eligibility; this is a result of the initial positioning of the start and end cursors, which requires the pages under them to be present in memory. This point is not particularly important operationally but can create complications for writing tests.</p>
<p>Finally note that currently the initial eviction attempt is done unconditionally even in cases where we could determine beforehand that the page will be ineligible. This causes it to be evicted and read in again, which is suboptimal, and should perhaps be improved at some point.</p>
<h1><a class="anchor" id="ft_deleted_generation"></a>
Generation of other deleted pages</h1>
<p>As mentioned earlier, there are four ways besides fast-truncate that deleted pages can appear.</p>
<p>First, the checkpoint cleanup code in <code>bt_sync.c</code> discards pages that it finds contain only obsolete values, instead of writing them out. The ref state becomes <code>WT_REF_DELETED</code>, no <code>page_del</code> is generated, and when the checkpoint reaches the parent internal page any prior on-disk page image will be dropped and no cell will be produced.</p>
<p>Second, pages that reconcile empty end up deleted. During a checkpoint this happens in the checkpoint cleanup; in eviction, it happens in the <code>WT_PM_REC_EMPTY</code> case of <code>__evict_page_dirty_update</code>. The ref state becomes <code>WT_REF_DELETED</code> and no <code>page_del</code> is generated. (Also note that <code>WT_REF_MEM</code> pages with <code>WT_PM_REC_EMPTY</code> reconciliation results are explicitly skipped during internal page reconciliation.)</p>
<p>In VLCS, empty deleted pages are inserted during certain internal page reads; see <a class="el" href="arch-fast-truncate.html#ft_vlcs">VLCS considerations</a>.</p>
<p>Finally, new trees are created with a single empty deleted leaf page, because creating the tree with no leaves at all causes problems.</p>
<h1><a class="anchor" id="ft_page_skip"></a>
Skipping deleted pages</h1>
<p>There are two separate skip functions for skipping deleted pages during tree walks. The basic skip function is <code>__wt_delete_page_skip</code> in <code>bt_delete.c</code>; it is always called in tree walks when <code>WT_READ_SKIP_DELETED</code> is set, which is all tree walks except <a class="el" href="arch-rts.html">Rollback to Stable (RTS)</a>. It checks for whether the ref state is <code>WT_REF_DELETED</code> and the truncation is visible to the caller.</p>
<p>As in other cases (see <a class="el" href="arch-fast-truncate.html#ft_visibility">Notes on visibility</a>) we must treat prepared truncations as not visible; in order to generate prepare conflicts we cannot skip over truncations that are prepared but not yet committed.</p>
<p>The other skip function is <code>__wt_btcur_skip_page</code> in <code>btree_inline.h</code>. This is used by cursor next and previous to skip over deleted pages in those traversals specifically, and in addition to checking for <code>WT_REF_DELETED</code> with visible <code>page_del</code>, it also inspects the address cell. If the page is in memory and unmodified and the address cell contains page-delete information, it checks for the visibility of that deletion. Failing that, it checks the time aggregate in case all the values on the page are no longer visible, e.g. because the page was slow-truncated and reconciled.</p>
<p>For an unmodified in-memory page the deletion information in the address should be the same as present in the ref's <code>page_del</code> structure. However, inspecting the unpacked copy instead, which is free since we are unpacking the cell to look at the time aggregate anyway, makes this check independent of the lifecycle of the ref's <code>page_del</code>. This was more important in previous iterations of the code than it is now; however, in principle it's possible to drop the ref's <code>page_del</code> immediately upon instantiation in a read-only tree, since it is kept for internal page reconciliation and pages in read-only trees are never reconciled. Checking the unpacked information here avoids interfering with that option.</p>
<p>Note that <code>__wt_btcur_skip_page</code> is passed to the tree-walk code as a custom skip function, which means that when it's used <em>both</em> it and <code>__wt_delete_page_skip</code> are checked. This is not optimal and probably ought to be tidied. Furthermore, it is unclear whether these functions really need to be different; that is, it may be that the additional time aggregate check in <code>__wt_btcur_skip_page</code> should be deployed for all tree walks. (If not, the reason should be discovered and documented.)</p>
<h1><a class="anchor" id="ft_vlcs"></a>
VLCS considerations</h1>
<p>In row-store, discarding a chunk of the namespace has no particular effect. Leaf pages support insertion at the beginning and at the end (as well as in the middle), so if the internal page structure directs a search to a particular leaf page there's always a place to put any updates that might be generated.</p>
<p>In VLCS this is different; insertions are supported only at the ends of pages, in the append list. Historically this was furthermore only allowed on the last page of the tree; the namespace begins at 1 and all keys between 1 and the last key in the tree existed on some particular leaf page, possibly in a deleted-value cell.</p>
<p>Extending fast-truncate and deleted support to VLCS requires allowing chunks of the namespace to be discarded. In most cases this is harmless; searches into that portion of the namespace will be directed by the internal page structure to the next page to the left and any updates will appear on its append list.</p>
<p>However, if the leftmost child of an internal page is discarded, a problem arises: searches for that portion of the namespace still go to that internal page, because its start key hasn't changed (and can't change), but now the leftmost child begins at some later key. There's now nowhere for the search to go, and things go downhill from there.</p>
<p>One possible solution to this problem is to use the split code to reinsert an empty page in the leftmost slot on demand. This was rejected as dangerous (violates previous assumptions, extremely difficult to test or verify) so instead steps were put in place to avoid ever discarding the leftmost child.</p>
<p>These steps are:</p><ol type="1">
<li>Insert an empty deleted leaf page at internal page inmem time if the first child begins after the internal page itself.</li>
<li>Don't allow eviction to trigger a reverse split going upwards from the leftmost child, because that discards the page. (Note that in most cases the same reverse split will then promptly happen anyway, coming from the next child.)</li>
<li>When doing a split, don't discard the leftmost child even if it's deleted.</li>
</ol>
<p>Note that this extra page never appears on disk.</p>
<p>There is one other consideration, which is that normally VLCS leaf pages never reconcile empty; instead they reconcile with a single deleted-value cell, possibly with a large RLE count. These pages are detected at the end of leaf reconciliation and converted to empty pages.</p>
<h1><a class="anchor" id="ft_flcs"></a>
FLCS and deleted pages</h1>
<p>Fast-truncate and deleted pages in general are not supported in FLCS. Most of the code is in place (since deleted and instantiated page handling mostly occurs in the internal page code and this is shared with VLCS) but there's a showstopper problem: because there are no deleted values (deleted values read back as zero) there are also no gaps in the namespace. In particular, if we truncate a range, discard the pages, and then read through the gap we need to read back the entire truncated namespace as zero one entry at a time. That requires knowing how big the gaps are; and while that information is encoded in the internal page structure, it is not <em>available</em> from the internal page structure. Currently this looks infeasible to support, though it's possible that there's some clever solution nobody's thought of yet.</p>
<p>This is perhaps unfortunate because slow-truncating FLCS pages (which contain large numbers of rows with very small values) is particularly expensive.</p>
<p>For FLCS, fast-truncate is inhibited by checking for it and clearing <code>WT_READ_TRUNCATE</code> in the page-walk code; similarly, checkpoint cleanup avoids discarding FLCS pages. Because values are never deleted, pages never become empty; no special handling is needed to prevent deleted pages appearing via that mechanism. However, there is still a bit of FLCS-specific code there to avoid examining pages that are not in memory (unlike in row-store and VLCS) because this is not useful.</p>
<p>The empty deleted page attached to a new tree is still created; it will turn into an empty in-memory page on the first search, and in principle can change back to a deleted page if then evicted immediately. However, once an update is posted to it (even if later rolled back) it will not reconcile empty.</p>
<h1><a class="anchor" id="ft_visibility"></a>
Notes on visibility</h1>
<p>As mentioned previously, for deleted page purposes prepared transactions must be treated as not visible. This differs from the treatment elsewhere (for ordinary updates, prepared values are visible but cause <code>WT_PREPARE_CONFLICT</code> if visited) and the special-case handling is wrapped into a pair of functions <code>__wt_page_del_visible</code> and <code>__wt_page_del_visible_all</code>.</p>
<p>These functions take a boolean argument that enables this special-case handling; this is only an optimization, since in one place (parent page eviction checks) uncommitted transactions have already been excluded and the check for a prepared transaction is redundant.</p>
<p>It turns out that (so far at least) <em>all</em> visibility references to truncations require treating prepared truncations as invisible. In the case of page skipping, it is necessary to visit pages with a prepared truncation so as to be able to generate WT_PREPARE_CONFLICT if needed. This is also true when reading pages in: we cannot skip reading a page because its truncation is visible-all unless it is actually committed.</p>
<p>The other visibility checks appear in reconciliation and eviction, and in those cases we need to treat prepared truncations as invisible because we cannot write them to disk.</p>
<h1><a class="anchor" id="ft_misc"></a>
Miscellaneous other notes</h1>
<p>After recovery, when the write generations are bumped, it is necessary to check and possibly discard the transaction IDs (and sometimes the timestamps) in loaded <code>page_del</code> structures, so that they contain the values they would if unpacked with the new write generations. Otherwise we might start using transaction IDs from a previous run. This is done by <code>__wt_delete_redo_window_cleanup</code> in <code>bt_delete.c</code>.</p>
<p>Internal pages are never fast-truncated. In most cases if a truncate spans all the children of an internal page, at the point when the child refs are discarded a reverse split will be triggered and this will cause the internal page to be discarded as well. However, it is possible for internal pages to become deleted pages if they reconcile empty. At this point the state is set to <code>WT_REF_DELETED</code> and no <code>page_del</code> is created, as with other cases of reconciling empty. If this portion of the namespace is subsequently searched, instantiation occurs; however, instantiation will create an empty leaf page. There is a hook in <code>__wt_btree_new_leaf_page</code> that changes the type from <code>WT_REF_FLAG_INTERNAL</code> to <code>WT_REF_FLAG_LEAF</code> at this point. (It might be tidier if this change happened at the time of deletion instead.)</p>
<h1><a class="anchor" id="ft_pointers"></a>
Pointers to pieces of the implementation</h1>
<table class="doxtable">
<tr>
<th>Source file</th><th>Type</th><th>Symbol</th><th>Description </th></tr>
<tr>
<td>btmem.h</td><td>Enumerator</td><td><code>WT_REF_DELETED</code> </td><td>The deleted ref state (with the other ref states). </td></tr>
<tr>
<td>btmem.h</td><td>Read flag</td><td><code>WT_READ_TRUNCATE</code> </td><td>The flag passed to tree-walk that causes eligible pages to be truncated instead of visited. </td></tr>
<tr>
<td>btmem.h</td><td>Page header flag</td><td><code>WT_PAGE_FT_UPDATE</code> </td><td>The on-disk flag that indicates the presence of page delete information in deleted-address cells. </td></tr>
<tr>
<td>btmem.h</td><td>Update flag</td><td><code>WT_UPDATE_RESTORED_FAST_TRUNCATE</code> </td><td>A flag used in prepare handling to identify updates from instantiation. </td></tr>
<tr>
<td>btmem.h</td><td>Structure member</td><td><code>WT_PAGE_MODIFY::instantiated</code> </td><td>The flag marking an in-memory <code>WT_REF</code> as an instantiated page. </td></tr>
<tr>
<td>btmem.h</td><td>Structure member</td><td><code>WT_PAGE_MODIFY::inst_updates</code> </td><td>The updates used to instantiate an unresolved truncation. </td></tr>
<tr>
<td>btmem.h</td><td>Type</td><td><code>WT_PAGE_DELETED</code> </td><td>The structure that holds page deletion information. </td></tr>
<tr>
<td>btmem.h</td><td>Structure member</td><td><code>WT_REF::page_del</code> </td><td><p class="starttd">The page deletion information for a <code>WT_REF</code>.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>cell.h</td><td>Enumerator</td><td><code>WT_CELL_ADDR_DEL</code> </td><td>The deleted-address cell type (along with the other cell types). </td></tr>
<tr>
<td>cell.h</td><td>Misc</td><td><code>WT_CELL</code> </td><td>The allocation of space in <code>WT_CELL</code> for the on-disk deletion information. </td></tr>
<tr>
<td>cell.h</td><td>Structure member</td><td><code>WT_CELL_UNPACK_ADDR::page_del</code> </td><td><p class="starttd">The deletion information unpacked from an address cell.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>reconcile.h</td><td>Structure member</td><td><code>WT_CHILD_MODIFY_STATE::del</code> </td><td><p class="starttd">A <code>WT_PAGE_DELETED</code> that allows <code>__wt_rec_child_modify</code> to return page deleted information about a child ref after unlocking it.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>txn.h</td><td>Enumerator</td><td><code>WT_TXN_OP_REF_DELETE</code> </td><td>The operation type for a fast-truncate transaction operation. </td></tr>
<tr>
<td>txn.h</td><td>Structure member</td><td><code>WT_TXN_OP::ref</code> </td><td><p class="starttd">The data for a fast-truncate transaction operation: the <code>WT_REF</code>.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>btree_inline.h</td><td>Structure member</td><td><code>WT_ADDR_COPY::page_deleted</code> </td><td>Page deletion information unpacked from the on-disk cell by <code>__wt_ref_addr_copy</code>. </td></tr>
<tr>
<td>btree_inline.h</td><td>Structure member</td><td><code>WT_ADDR_COPY::del_set</code> </td><td>True if page deletion information was unpacked. </td></tr>
<tr>
<td>btree_inline.h</td><td>Hook</td><td>in <code>__wt_ref_addr_copy</code> </td><td>Return the page delete information unpacked from the address. </td></tr>
<tr>
<td>btree_inline.h</td><td>Function</td><td><code>__wt_page_del_visible</code> </td><td>Function for checking thread visibility of a <code>WT_PAGE_DELETED</code>. </td></tr>
<tr>
<td>btree_inline.h</td><td>Function</td><td><code>__wt_page_del_visible_all</code> </td><td>Function for checking global visibility of a <code>WT_PAGE_DELETED</code>. </td></tr>
<tr>
<td>btree_inline.h</td><td>Function</td><td><code>__wt_page_del_committed</code> </td><td>Function for checking whether a <code>WT_PAGE_DELETED</code> is committed. </td></tr>
<tr>
<td>btree_inline.h</td><td>Function</td><td><code>__wt_btcur_skip_page</code> </td><td><p class="starttd">The page-skip function used by cursor next and previous.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>reconcile_inline.h</td><td>Hook</td><td>in <code>__wt_rec_cell_build_addr</code> </td><td><p class="starttd">A hook to choose <code>WT_CELL_ADDR_DEL</code> cells when needed and propagate any passed-in page deletion information to the packing code.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>timestamp_inline.h</td><td>Macro</td><td><code>WT_TIME_AGGREGATE_UPDATE_PAGE_DEL</code> </td><td><p class="starttd">Akin to <code>WT_TIME_AGGREGATE_UPDATE</code> but for a <code>WT_PAGE_DELETED</code>; used in internal page reconciliation.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>txn_inline.h</td><td>Function</td><td><code>__wt_txn_op_delete_apply_prepare_state</code> </td><td>The code for updating <code>WT_PAGE_DELETED</code> at prepare time. </td></tr>
<tr>
<td>txn_inline.h</td><td>Function</td><td><code>__wt_txn_op_commit_apply_timestamps</code> </td><td>Part of the code for updating <code>WT_PAGE_DELETED</code> at commit time. (The rest is in <code>__wt_txn_commit</code> itself. Note that the rollback-time update is in <code>bt_delete.c</code>.) </td></tr>
<tr>
<td>txn_inline.h</td><td>Hook</td><td>in <code>__wt_txn_op_set_timestamp</code> </td><td>Call <code>__wt_txn_op_delete_apply_prepare_state</code> and <code>__wt_txn_op_commit_apply_timestamps</code>. </td></tr>
<tr>
<td>txn_inline.h</td><td>Function</td><td><code>__wt_txn_modify_page_delete</code> </td><td><p class="starttd">This records a fast-truncate in the current transaction.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>cell_inline.h</td><td>Function</td><td><code>__cell_page_del_window_cleanup</code> </td><td>Akin to <code>__cell_kv_window_cleanup</code> except for <code>WT_PAGE_DELETED</code>. </td></tr>
<tr>
<td>cell_inline.h</td><td>Function</td><td><code>__cell_redo_page_del_cleanup</code> </td><td>Function that redoes the timestamp cleanup for a <code>WT_PAGE_DELETED</code> structure; used after we bump write generations at the end recovery. </td></tr>
<tr>
<td>cell_inline.h</td><td>Hook</td><td>in <code>__wt_cell_unpack_safe</code> </td><td>Unpack the page deletion information from deleted-address cells. </td></tr>
<tr>
<td>cell_inline.h</td><td>Hook</td><td>in <code>__wt_cell_pack_addr</code> </td><td><p class="starttd">Pack the page deletion information into deleted-address cells.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>bt_curnext.c</td><td>Hook</td><td>in <code>__wt_btcur_next_prefix</code> </td><td>Accept a flag argument that sets <code>WT_READ_TRUNCATE</code>. </td></tr>
<tr>
<td>bt_curnext.c</td><td>Hook</td><td>in <code>__wt_btcur_next</code> </td><td><p class="starttd">Accept a flag argument that sets <code>WT_READ_TRUNCATE</code>.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>bt_curprev.c</td><td>Hook</td><td>in <code>__wt_btcur_prev</code> </td><td><p class="starttd">Accept a flag argument that sets <code>WT_READ_TRUNCATE</code>.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>bt_cursor.c:</td><td>Function</td><td><code>__wt_btcur_range_truncate</code> (and others)</td><td><p class="starttd">The cursor-level truncate code lives here.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>bt_debug.c</td><td>Hook</td><td>in <code>__debug_cell_int</code> </td><td>There should be a hook to print the deletion information for <code>WT_CELL_ADDR_DEL</code> cells, but as of this writing it is missing. </td></tr>
<tr>
<td>bt_debug.c</td><td>Hook</td><td>in <code>__debug_ref</code> or possibly <code>__debug_ref_state</code> </td><td><p class="starttd">There should be a hook to print the deletion information for deleted and instantiated pages, but as of this writing it is missing.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>bt_delete.c</td><td>Function</td><td><code>__wt_delete_page</code> </td><td>The implementation of fast-truncate itself. </td></tr>
<tr>
<td>bt_delete.c</td><td>Function</td><td><code>__wt_delete_page_rollback</code> </td><td>Code for rolling back a fast-truncate, used by transaction rollback (but not RTS). </td></tr>
<tr>
<td>bt_delete.c</td><td>Function</td><td><code>__delete_redo_window_cleanup_internal</code> </td><td>Page-visitor part of <code>__wt_delete_redo_window_cleanup</code>. </td></tr>
<tr>
<td>bt_delete.c</td><td>Function</td><td><code>__delete_redo_window_cleanup_skip</code> </td><td>Custom page skip function for <code>__wt_delete_redo_window_cleanup</code>. </td></tr>
<tr>
<td>bt_delete.c</td><td>Function</td><td><code>__wt_delete_redo_window_cleanup</code> </td><td>Iterate a tree to do redo time window cleanup on already-loaded <code>WT_PAGE_DELETED</code> structures after recovery. </td></tr>
<tr>
<td>bt_delete.c</td><td>Function</td><td><code>__wt_delete_page_skip</code> </td><td>The page skip function to skip deleted pages that's used in ordinary tree walks. </td></tr>
<tr>
<td>bt_delete.c</td><td>Function</td><td><code>__tombstone_update_alloc</code> </td><td>Allocate a tombstone for instantiation. </td></tr>
<tr>
<td>bt_delete.c</td><td>Function</td><td><code>__instantiate_tombstone</code> </td><td>Allocate and remember a tombstone during instantiation. (Possibly this and <code>__tombstone_update_alloc</code> should be folded together eventually.) </td></tr>
<tr>
<td>bt_delete.c</td><td>Function</td><td><code>__instantiate_col_var</code> </td><td>Instantiate a VLCS page. </td></tr>
<tr>
<td>bt_delete.c</td><td>Function</td><td><code>__instantiate_row</code> </td><td>Instantiate a row-store page. </td></tr>
<tr>
<td>bt_delete.c</td><td>Function</td><td><code>__wt_delete_page_instantiate</code> </td><td><p class="starttd">Perform instantiation of tombstones on a deleted page when reading it into memory.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>bt_discard.c</td><td>Hook</td><td>in <code>__free_page_modify</code> </td><td>Discard the truncate-related fields of <code>WT_PAGE_MODIFY</code>. </td></tr>
<tr>
<td>bt_discard.c</td><td>Hook</td><td>in <code>__wt_free_ref</code> </td><td><p class="starttd">Discard the <code>page_del</code> field of <code>WT_REF</code>.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>bt_handle.c</td><td>Hook</td><td>in <code>__wt_btree_new_leaf_page</code> </td><td><p class="starttd">Change the ref type from <code>WT_REF_FLAG_INTERNAL</code> to <code>WT_REF_FLAG_LEAF</code>; if internal pages are deleted and later come back to life they come back to life as leaves.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>bt_page.c</td><td>Hook</td><td>in <code>__wt_page_inmem</code> </td><td>When counting how many refs to allocate on a column-store internal page, figure out when we need to allocate an extra one to insert an empty page in the leftmost slot. </td></tr>
<tr>
<td>bt_page.c</td><td>Hook</td><td>in <code>__inmem_col_int</code> </td><td>Load deleted-address cells as deleted <code>WT_REF</code> structures. </td></tr>
<tr>
<td>bt_page.c</td><td>Hook</td><td>in <code>__inmem_row_int</code> </td><td>Load deleted-address cells as deleted <code>WT_REF</code> structures. </td></tr>
<tr>
<td>bt_page.c</td><td>Hook</td><td>in <code>__page_read</code> </td><td>Call the instantiation code when needed. Also, avoid reading deleted pages if we don't need the pre-deletion contents, or if there aren't any at all. Get an empty page instead and mark it instantiated. </td></tr>
<tr>
<td>bt_read.c</td><td>Hook</td><td>in <code>__wt_page_in_func</code> </td><td><p class="starttd">Return <code>WT_NOTFOUND</code> instead of reading the page if we are skipping deleted pages.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>bt_split.c</td><td>Hook</td><td>in <code>__split_parent_discard_ref</code> </td><td>Discard the <code>page_del</code> field of the <code>WT_REF</code>. </td></tr>
<tr>
<td>bt_split.c</td><td>Hook</td><td>in <code>__split_parent</code> </td><td><p class="starttd">For VLCS trees, avoid discarding the leftmost child even if it's deleted.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>bt_vrfy.c</td><td>Hook</td><td>in <code>__verify_tree</code> </td><td>Allow for deleted-address cells when checking the cell type in the address against the page type. </td></tr>
<tr>
<td>bt_vrfy.c</td><td>Hook</td><td>in <code>__verify_tree</code> </td><td>Allow namespace gaps in VLCS but not in FLCS. </td></tr>
<tr>
<td>bt_vrfy.c</td><td>Hook</td><td>in <code>__verify_page_content_int</code> </td><td><p class="starttd">Handle deleted-address cells.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>bt_vrfy_dsk.c</td><td>Function</td><td><code>__verify_dsk_addr_page_del</code> </td><td><p class="starttd">Validate and crosscheck the page deletion information discovered in on-disk address cells.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>bt_walk.c</td><td>Hook</td><td>in <code>__tree_walk_internal</code> </td><td>Disable fast-truncate for FLCS. </td></tr>
<tr>
<td>bt_walk.c</td><td>Hook</td><td>in <code>__tree_walk_internal</code> </td><td>Engage <code>WT_READ_SKIP_DELETED</code> by default. </td></tr>
<tr>
<td>bt_walk.c</td><td>Hook</td><td>in <code>__tree_walk_internal</code> </td><td>Call <code>__wt_delete_page_skip</code> when <code>WT_READ_SKIP_DELETED</code> is set. </td></tr>
<tr>
<td>bt_walk.c</td><td>Hook</td><td>in <code>__tree_walk_internal</code> </td><td>Call <code>__wt_delete_page</code> when <code>WT_READ_TRUNCATE</code> is set. </td></tr>
<tr>
<td>bt_walk.c</td><td>Hook</td><td>in <code>__tree_walk_skip_count_callback</code> </td><td><p class="starttd">Call <code>__wt_delete_page_skip</code> explicitly.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>conn_dhandle.c</td><td>Hook</td><td>in <code>__wt_dhandle_update_write_gens</code> </td><td><p class="starttd">Call <code>__wt_delete_redo_window_cleanup</code>.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>evict_page.c</td><td>Function</td><td><code>__evict_delete_ref</code> </td><td>Delete evicted pages and check for/trigger reverse splits. </td></tr>
<tr>
<td>evict_page.c</td><td>Hook</td><td>in <code>__evict_page_clean_update</code> </td><td>Delete pages with <code>__evict_delete_ref</code> that are clean and have no on-disk address. </td></tr>
<tr>
<td>evict_page.c</td><td>Hook</td><td>in <code>__evict_page_dirty_update</code> </td><td>Use <code>__evict_delete_ref</code> to delete pages that reconciled empty. </td></tr>
<tr>
<td>evict_page.c</td><td>Hook</td><td>in <code>__evict_page_clean_update</code> </td><td>Check for instantiated pages and set the ref state back to <code>WT_REF_DELETED</code>. </td></tr>
<tr>
<td>evict_page.c</td><td>Hook</td><td>in <code>__evict_child_check</code> </td><td><p class="starttd">Prohibit evicting internal pages with uncommitted truncations.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>rec_child.c</td><td>Function</td><td><code>__rec_child_deleted</code> </td><td>Handle the processing for deleted and instantiated pages during internal page reconciliation. </td></tr>
<tr>
<td>rec_child.c</td><td>Hook</td><td>in <code>__wt_rec_child_modify</code> </td><td><p class="starttd">Call <code>__rec_child_deleted</code> when necessary.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>rec_col.c</td><td>Hook</td><td>in <code>__wt_rec_col_int</code> </td><td>Write out deleted address cells when needed. </td></tr>
<tr>
<td>rec_col.c</td><td>Hook</td><td>in <code>__wt_rec_col_var</code> </td><td><p class="starttd">Reconcile empty instead if we get one big deleted-value cell.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>rec_row.c</td><td>Hook</td><td>in <code>__wt_rec_row_int</code> </td><td><p class="starttd">Write out deleted address cells when needed.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>rec_write.c</td><td>Hook</td><td>in <code>__rec_split_write_header</code> </td><td>Set WT_PAGE_FT_UPDATE on the page header if appropriate. </td></tr>
<tr>
<td>rec_write.c</td><td>Hook</td><td>in <code>__rec_write_wrapup</code> </td><td><p class="starttd">Clear the instantiated flag and discard the page deletion information for instantiated pages.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>txn.c</td><td>Hook</td><td>in <code>__wt_txn_commit</code> </td><td>Clear <code>inst_updates</code> and set the <code>committed</code> field in <code>WT_PAGE_DELETED</code>. </td></tr>
<tr>
<td>txn.c</td><td>Hook</td><td>in <code>__wt_txn_prepare</code> </td><td>Call <code>__wt_txn_op_delete_apply_prepare_state</code>. </td></tr>
<tr>
<td>txn.c</td><td>Hook</td><td>in <code>__wt_txn_rollback</code> </td><td><p class="starttd">Call <code>__wt_delete_page_rollback</code>.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td>txn_rollback_to_stable.c</td><td>Hook</td><td>in <code>__rollback_page_needs_abort</code> </td><td>Check <code>page_del</code> when deciding whether the page contains unstable values that need to be examined. </td></tr>
<tr>
<td>txn_rollback_to_stable.c</td><td>Hook</td><td>in <code>__rollback_to_stable_page_skip</code> </td><td><p class="starttd">Check <code>page</code> del when deciding whether to skip over the page.</p>
<p class="endtd"></p>
</td></tr>
</table>
<p>Note also that <code>txn_log.c</code> contains the functions <code>__wt_txn_truncate_log</code> and <code>__wt_txn_truncate_end</code> for logging truncates, and various hooks for handling truncate log records. (Further hooks exist in <code>log_auto.c</code>.) However, logging of truncates happens at the cursor level and not the page level. The functions are called from the cursor code. Page-level fast-truncate actions themselves are not logged. Replaying a truncation from the log may (in fact, likely will as more pages will be on-disk and eligible) fast-truncate different or more pages than the original operation. This is correct because there is supposed to be no semantic difference between fast-truncate and slow-truncate. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">Reference Guide</a></li><li class="navelem"><a class="el" href="arch-index.html">WiredTiger Architecture Guide</a></li><li class="navelem"><a class="el" href="arch-toc-fundamentals.html">Fundamentals</a></li>
    <li class="footer">Copyright (c) 2008-present MongoDB, Inc.  All rights reserved.  Contact <a href="mailto:info@wiredtiger.com">info@wiredtiger.com</a> for more information.</li>
  </ul>
</div>
</body>
</html>
