<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>WiredTiger: Backups  in Java</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="wiredtiger.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://wiredtiger.com/"><img alt="Logo" src="LogoFinal-header.png" alt="WiredTiger" /></a></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Version 10.0.0</span>
   </div>
   <div id="projectbrief"><!-- 10.0.0 --></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<div class="banner">
  <a href="https://github.com/wiredtiger/wiredtiger">Fork me on GitHub</a>
  <a class="last" href="http://groups.google.com/group/wiredtiger-users">Join my user group</a>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('backup_lang_java.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Backups in Java </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>WiredTiger cursors provide access to data from a variety of sources. One of these sources is the list of files required to perform a backup of the database. The list may be the files required by all of the objects in the database, or a subset of the objects in the database.</p>
<p>WiredTiger backups are "on-line" or "hot" backups, and applications may continue to read and write the databases while a snapshot is taken.</p>
<h1><a class="anchor" id="backup_process_lang_java"></a>
Backup from an application</h1>
<ol type="1">
<li>Open a cursor on the <code>"backup:"</code> data source, which begins the process of a backup.</li>
<li>Copy each file returned by the Cursor.next method to the backup location, for example, a different directory. Do not reuse backup locations unless all files have first been removed from them, in other words, remove any previous backup information before using a backup location.</li>
<li>Close the cursor; the cursor must not be closed until all of the files have been copied.</li>
</ol>
<p>The directory into which the files are copied may subsequently be specified as a directory to the <code>wiredtiger.open</code> function and accessed as a WiredTiger database home.</p>
<p>Copying the database files for a backup does not require any special alignment or block size (specifically, Linux or Windows filesystems that do not support read/write isolation can be safely read for backups).</p>
<p>The database file may grow in size during the copy, and the file copy should not consider that an error. Blocks appended to the file after the copy starts can be safely ignored, that is, it is correct for the copy to determine an initial size of the file and then copy that many bytes, ignoring any bytes appended after the backup cursor was opened.</p>
<p>The cursor must not be closed until all of the files have been copied, however, there is no requirement the files be copied in any order or in any relationship to the Cursor.next calls, only that all files have been copied before the cursor is closed. For example, applications might aggregate the file names from the cursor and then list the file names as arguments to a file archiver such as the system tar utility.</p>
<p>During the period the backup cursor is open, database checkpoints can be created, but checkpoints created prior to the backup cursor cannot be deleted. Additionally while the backup cursor is open automatic log file archiving, even if enabled, will not reclaim any log files.</p>
<p>Additionally, if a crash occurs during the period the backup cursor is open and logging is disabled (in other words, when depending on checkpoints for durability), then the system will be restored to the most recent checkpoint prior to the opening of the backup cursor, even if later database checkpoints were completed. <b>Note this exception to WiredTiger's checkpoint durability guarantees.</b></p>
<p>The following is a programmatic example of creating a backup:</p>
<div class="fragment"><div class="line">    Cursor cursor;</div><div class="line">    String filename;</div><div class="line">    <span class="keywordtype">int</span> ret = 0;</div><div class="line">        String databasedir = <span class="stringliteral">&quot;/path/database&quot;</span>;</div><div class="line">        String backdir = <span class="stringliteral">&quot;/path/database.backup&quot;</span>;</div><div class="line">        <span class="keyword">final</span> String sep = File.separator;</div><div class="line"></div><div class="line">        <span class="keywordflow">try</span> {</div><div class="line">            <span class="comment">/* Create the backup directory. */</span></div><div class="line">            <span class="keywordflow">if</span> (!(<span class="keyword">new</span> File(backdir)).mkdir()) {</div><div class="line">                System.err.println(progname + <span class="stringliteral">&quot;: cannot create backup dir: &quot;</span> +</div><div class="line">                                   backdir);</div><div class="line">                <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="comment">/* Open the backup data source. */</span></div><div class="line">            cursor = session.<a class="code" href="struct_w_t___s_e_s_s_i_o_n.html#afb5b4a69c2c5cafe411b2b04fdc1c75d">open_cursor</a>(<span class="stringliteral">&quot;backup:&quot;</span>, null, null);</div><div class="line"></div><div class="line">            <span class="comment">/* Copy the list of files. */</span></div><div class="line">            <span class="keywordflow">while</span> ((ret = cursor.next()) == 0 &amp;&amp;</div><div class="line">                   (filename = cursor.getKeyString()) != null) {</div><div class="line">                String src = databasedir + sep + filename;</div><div class="line">                String dest = backdir + sep + filename;</div><div class="line">                java.nio.file.Files.copy(</div><div class="line">                    <span class="keyword">new</span> java.io.File(src).toPath(), </div><div class="line">                    <span class="keyword">new</span> java.io.File(dest).toPath(),</div><div class="line">                    java.nio.file.StandardCopyOption.REPLACE_EXISTING,</div><div class="line">                    java.nio.file.StandardCopyOption.COPY_ATTRIBUTES);</div><div class="line">            }</div><div class="line">            <span class="keywordflow">if</span> (ret == wiredtiger.WT_NOTFOUND)</div><div class="line">        ret = 0;</div><div class="line">            <span class="keywordflow">if</span> (ret != 0)</div><div class="line">                System.err.println(progname +</div><div class="line">                   <span class="stringliteral">&quot;: cursor next(backup:) failed: &quot;</span> +</div><div class="line">                   wiredtiger.wiredtiger_strerror(ret));</div><div class="line"></div><div class="line">            ret = cursor.close();</div><div class="line">        }</div><div class="line">        <span class="keywordflow">catch</span> (Exception ex) {</div><div class="line">            System.err.println(progname +</div><div class="line">                <span class="stringliteral">&quot;: backup failed: &quot;</span> + ex.toString());</div><div class="line">        }</div></div><!-- fragment --><p> When logging is enabled, opening the backup cursor forces a log file switch. The reason is so that only data that was committed and visible at the time of the backup is available in the backup when that log file is included in the list of files. WiredTiger offers a mechanism to gather additional log files that may be created during the backup.</p>
<p>Since backups can take a long time, it may be desirable to catch up at the end of a backup with the log files so that operations that occurred during backup can be recovered. WiredTiger provides the ability to open a duplicate backup cursor with the configuration <code>target=log:</code>. This secondary backup cursor will return the file names of all log files via <code>dup_cursor-&gt;get_key()</code>. There will be overlap with log file names returned in the original cursor. The user only needs to copy file names that are new but there is no error copying all log file names returned. This secondary cursor must be closed explicitly prior to closing the parent backup cursor.</p>
<div class="fragment"><div class="line">            <span class="comment">/* Open the backup data source. */</span></div><div class="line">            cursor = session.<a class="code" href="struct_w_t___s_e_s_s_i_o_n.html#afb5b4a69c2c5cafe411b2b04fdc1c75d">open_cursor</a>(<span class="stringliteral">&quot;backup:&quot;</span>, null, null);</div><div class="line">            <span class="comment">/* Open a duplicate cursor for additional log files. */</span></div><div class="line">            dup_cursor = session.<a class="code" href="struct_w_t___s_e_s_s_i_o_n.html#afb5b4a69c2c5cafe411b2b04fdc1c75d">open_cursor</a>(null, cursor, <span class="stringliteral">&quot;target=(\&quot;log:\&quot;)&quot;</span>);</div></div><!-- fragment --><p> In cases where the backup is desired for a checkpoint other than the most recent, applications can discard all checkpoints subsequent to the checkpoint they want using the Session.checkpoint method. For example:</p>
<div class="fragment"><div class="line">    ret = session.<a class="code" href="struct_w_t___s_e_s_s_i_o_n.html#a6550c9079198955c5071583941c85bbf">checkpoint</a>(<span class="stringliteral">&quot;drop=(from=June01),name=June01&quot;</span>);</div></div><!-- fragment --> <h1><a class="anchor" id="backup_util_lang_java"></a>
Backup from the command line</h1>
<p>The <a class="el" href="command_line.html#util_backup">wt backup</a> command may also be used to create backups:</p>
<div class="fragment"><div class="line">rm -rf /path/database.backup &amp;&amp;</div><div class="line">    mkdir /path/database.backup &amp;&amp;</div><div class="line">    wt -h /path/database.source backup /path/database.backup</div></div><!-- fragment --><h1><a class="anchor" id="backup_incremental_lang_java-block"></a>
Block-based Incremental backup</h1>
<p>Once a full backup has been done, it can be rolled forward incrementally by copying only modified blocks and new files to the backup copy directory. The application is responsible for removing files that are no longer part of the backup when later incremental backups no longer return their name. This is especially important for WiredTiger log files that are no longer needed and must be removed before recovery is run.</p>
<p>Bulk-loads are not commit-level durable, that is, the creation and bulk-load of an object will not appear in the database log files. For this reason, applications doing incremental backups after a full backup should repeat the full backup step after doing a bulk-load to make the bulk-load durable. In addition, incremental backups after a bulk-load can cause recovery to report errors because there are log records that apply to data files which don't appear in the backup.</p>
<p>The following is the procedure for incrementally backing up a database using block modifications:</p>
<ol type="1">
<li>Perform a full backup of the database (as described above), with the additional configuration <code>incremental=</code>(enabled=true,this_id=”ID1”). The identifier specified in <code>this_id</code> starts block tracking and that identifier can be used in the future as the source of an incremental backup.</li>
<li>Begin the incremental backup by opening a backup cursor with the <code>backup:</code> URI and config string of <code>incremental=</code>(src_id="ID1",this_id="ID2"). Call this <code>backup_cursor</code>. Like a normal full backup cursor, this cursor will return the filename as the key. There is no associated value. The information returned will be based on blocks tracked since the time of the previous backup designated with "ID1". New block tracking will be started as "ID2" as well. WiredTiger will maintain modifications from two IDs, the current and the most recent completed one. Note that all backup identifiers are subject to the same naming restrictions as other configuration naming. See <a class="el" href="config_strings_lang_java.html#config_intro_lang_java">Introduction</a> for details.</li>
<li>For each file returned by <code>backup_cursor-&gt;next()</code>, open a duplicate backup cursor to do the incremental backup on that file. The list returned will also include log files (prefixed by <code>WiredTigerLog</code>) that need to be copied. Configure that duplicate cursor with <code>incremental=</code>(file=name). The <code>name</code> comes from the string returned from <code>backup_cursor-&gt;get_key()</code>. Call this incr_cursor.</li>
<li>The key format for the duplicate backup cursor, <code>incr_cursor</code>, is <code>qqq</code>, representing a file offset and size pair plus a type indicator for the range given. There is no associated value. The type indicator will be one of <code>WT_BACKUP_FILE</code> or <code>WT_BACKUP_RANGE</code>. For <code>WT_BACKUP_RANGE</code>, read the block from the source database file indicated by the file offset and size pair and write the block to the same offset in the backup database file, replacing the portion of the file represented by the offset/size pair. It is not an error for an offset/size pair to extend past the current end of the source file, and any missing file data should be ignored. For <code>WT_BACKUP_FILE</code>, the user can choose to copy the entire file in any way they choose, or to use the offset/size pair which will indicate the expected size WiredTiger knew at the time of the call.</li>
<li>Close the duplicate backup cursor, <code>incr_cursor</code>.</li>
<li>Repeat steps 3-5 as many times as necessary while <code>backup_cursor-&gt;next()</code> returns files to copy.</li>
<li>Close the backup cursor, <code>backup_cursor</code>.</li>
<li>Repeat steps 2-7 as often as desired.</li>
</ol>
<p>Full and incremental backups may be repeated as long as the backup database directory has not been opened and recovery run. Once recovery has run in a backup directory, you can no longer back up to that database directory.</p>
<p>An example of opening the backup data source for block-based incremental backup:</p>
<div class="fragment"><div class="line">            <span class="comment">/* Open the backup data source for incremental backup. */</span></div><div class="line">            cursor = session.<a class="code" href="struct_w_t___s_e_s_s_i_o_n.html#afb5b4a69c2c5cafe411b2b04fdc1c75d">open_cursor</a>(<span class="stringliteral">&quot;backup:&quot;</span>, null, <span class="stringliteral">&quot;incremental=(enabled,src_id=ID0,this_id=ID1)&quot;</span>);</div></div><!-- fragment --> <h1><a class="anchor" id="backup_incremental_lang_java"></a>
Log-based Incremental backup</h1>
<p>Once a backup has been done, it can be rolled forward incrementally by adding log files to the backup copy. Adding log files to the copy decreases potential data loss from switching to the copy, but increases the recovery time necessary to switch to the copy. To reset the recovery time necessary to switch to the copy, perform a full backup of the database. For example, an application might do a full backup of the database once a week during a quiet period, and then incrementally copy new log files into the backup directory for the rest of the week. Incremental backups may also save time when the tables are very large.</p>
<p>Bulk-loads are not commit-level durable, that is, the creation and bulk-load of an object will not appear in the database log files. For this reason, applications doing incremental backups after a full backup should repeat the full backup step after doing a bulk-load to make the bulk-load durable. In addition, incremental backups after a bulk-load can cause recovery to report errors because there are log records that apply to data files which don't appear in the backup.</p>
<p>By default, WiredTiger automatically removes log files no longer required for recovery. Applications wanting to use log files for incremental backup must first disable automatic log file removal using the <code>log=</code>(archive=false) configuration to <code>wiredtiger.open</code>.</p>
<p>The following is the procedure for incrementally backing up a database and removing log files from the original database home:</p>
<ol type="1">
<li>Perform a full backup of the database (as described above).</li>
<li>Open a cursor on the <code>"backup:"</code> data source, configured with the <code>"target=(\"log:\")"</code> target specified, which begins the process of an incremental backup.</li>
<li>Copy each log file returned by the Cursor.next method to the backup directory. It is not an error to copy a log file which has been copied before, but care should be taken to ensure each log file is completely copied as the most recent log file may grow in size while being copied.</li>
<li>If all log files have been successfully copied, archive the log files by calling the Session.truncate method with the URI <code>log:</code> and specifying the backup cursor as the start cursor to that method. (Note there is no requirement backups be coordinated with database checkpoints, however, an incremental backup will repeatedly copy the same files, and will not make additional log files available for archival, unless there was a checkpoint after the previous incremental backup.)</li>
<li>Close the backup cursor.</li>
</ol>
<p>Steps 2-5 can be repeated any number of times before step 1 is repeated. Full and incremental backups may be repeated as long as the backup database directory has not been opened and recovery run. Once recovery has run in a backup directory, you can no longer back up to that database directory.</p>
<p>An example of opening the backup data source for log-based incremental backup:</p>
<div class="fragment"><div class="line">            <span class="comment">/* Open the backup data source for incremental backup. */</span></div><div class="line">            cursor = session.<a class="code" href="struct_w_t___s_e_s_s_i_o_n.html#afb5b4a69c2c5cafe411b2b04fdc1c75d">open_cursor</a>(<span class="stringliteral">&quot;backup:&quot;</span>, null, <span class="stringliteral">&quot;target=(\&quot;log:\&quot;)&quot;</span>);</div></div><!-- fragment --> <h1><a class="anchor" id="backup_o_direct_lang_java"></a>
Backup and O_DIRECT</h1>
<p>Many Linux systems do not support mixing <code>O_DIRECT</code> and memory mapping or normal I/O to the same file. If <code>O_DIRECT</code> is configured for data or log files on Linux systems (using the wiredtiger_open <code>direct_io</code> configuration), any program used to copy files during backup should also specify <code>O_DIRECT</code> when configuring its file access. Likewise, when <code>O_DIRECT</code> is not configured by the database application, programs copying files should not configure <code>O_DIRECT</code>. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">Reference Guide</a></li><li class="navelem"><a class="el" href="programming_lang_java.html">Writing WiredTiger applications  in Java</a></li>
    <li class="footer">Copyright (c) 2008-2020 MongoDB, Inc.  All rights reserved.  Contact <a href="mailto:info@wiredtiger.com">info@wiredtiger.com</a> for more information.</li>
  </ul>
</div>
</body>
</html>
