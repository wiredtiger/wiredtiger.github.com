<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>WiredTiger: Configuration String Compilation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="sorttable.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="wiredtiger.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://wiredtiger.com/"><img alt="Logo" src="LogoFinal-header.png" alt="WiredTiger" /></a></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Version 11.3.0</span>
   </div>
   <div id="projectbrief"><!-- 11.3.0 --></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<div class="banner">
  <a href="https://github.com/wiredtiger/wiredtiger">Fork me on GitHub</a>
  <a class="last" href="http://groups.google.com/group/wiredtiger-users">Join my user group</a>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('arch-config-compile.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Configuration String Compilation </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><div class="arch_head"><table class="doxtable">
<tr>
<th rowspan="2" style="width:10%;"> <div><a href="arch-index.html"><img class="arch_thumbnail" src="wt_diagram.png" usemap="#wt_diagram_map" style="background-image: url(wt_diagram.png)"></a></div></th><th style="width:44%">Data Structures</th><th style="width:45%">Source Location</th></tr>
<map id="wt_diagram_map" name="wt_diagram_map">
<area shape="rect" id="id1" href="modules.html" title="modules.html" alt="" coords="248,128,283,144"/>
<area shape="rect" id="id2" href="arch-cache.html" title="arch-cache.html" alt="" coords="204,546,248,562"/>
<area shape="rect" id="id3" href="arch-cursor.html" title="arch-cursor.html" alt="" coords="234,224,280,240"/>
<area shape="rect" id="id4" href="arch-eviction.html" title="arch-eviction.html" alt="" coords="303,546,356,562"/>
<area shape="rect" id="id5" href="arch-logging.html" title="arch-logging.html" alt="" coords="388,650,443,666"/>
<area shape="rect" id="id6" href="arch-schema.html" title="arch-schema.html" alt="" coords="123,224,179,240"/>
<area shape="rect" id="id7" href="command_line.html" title="command_line.html" alt="" coords="374,23,430,39"/>
<area shape="rect" id="id8" href="arch-log-file.html" title="arch-log-file.html" alt="" coords="308,865,339,897"/>
<area shape="rect" id="id9" href="arch-metadata.html" title="arch-metadata.html" alt="" coords="25,328,89,344"/>
<area shape="rect" id="id10" href="arch-python.html" title="arch-python.html" alt="" coords="84,23,157,39"/>
<area shape="rect" id="id11" href="arch-snapshot.html" title="arch-snapshot.html" alt="" coords="297,441,371,457"/>
<area shape="rect" id="id12" href="arch-transaction.html" title="arch-transaction.html" alt="" coords="298,328,387,344"/>
<area shape="rect" id="id13" href="arch-hs.html" title="arch-hs.html" alt="" coords="93,642,140,674"/>
<area shape="rect" id="id14" href="arch-block.html" title="arch-block.html" alt="" coords="196,642,256,674"/>
<area shape="rect" id="id15" href="arch-dhandle.html" title="arch-dhandle.html" alt="" coords="144,320,205,352"/>
<area shape="rect" id="id16" href="arch-data-file.html" title="arch-data-file.html" alt="" coords="179,865,245,897"/>
<area shape="rect" id="id17" href="arch-row-column.html" title="arch-row-column.html" alt="" coords="117,433,205,465"/>
<area shape="rect" id="id18" href="arch-fs-os.html" title="arch-fs-os.html" alt="" coords="175,755,357,771"/>
</map>
<tr>
<td><code><code>WT_CONF</code></code></td><td><code><code>src/include/conf.h<br  />
src/conf/conf_bind.c<br  />
src/conf/conf_compile.c<br  />
src/conf/conf_get.c</code></code></td></tr>
</table>
</div><p> <b>Caution: the Architecture Guide is not updated in lockstep with the code base and is not necessarily correct or complete for any specific release.</b></p>
<h1><a class="anchor" id="compile_intro"></a>
Introduction</h1>
<p>WiredTiger's use of configuration strings in its API provides flexibility for callers, but when they are used in high performance code paths, they can introduce bottlenecks. This is typically because, in the worst case, internal WiredTiger code repeatedly checks for keys by scanning the entire configuration string. The longer the configuration string, the greater the scanning time. Compiled configuration strings provide a binary representation of the string, allowing for quick access to keys and their values.</p>
<p>The old configuration framework is known as <em>config</em>, where the new framework is <em>conf</em>. (We hope that a shorter name implies faster processing). The <em>conf</em> framework builds upon and uses elements of <em>config</em>.</p>
<h1><a class="anchor" id="compile_goals"></a>
Goals</h1>
<p>As the configuration compilation subsystem (conf) was introduced after the WiredTiger code and API reached stability, there is a set of performance improvement goals and two compatibility goals.</p>
<p>On the performance side, the new conf processing should greatly reduce the impact of these actions, which take the bulk of the time in traditional configuration processing:</p>
<ul>
<li>checking the passed in configuration string for errors. That is, checking for unknown keys, value type errors (number expected but not provided), numbers out of specified range, values not one of a set of choices. These various constraints for each configuration key are listed in <code>api_data.py</code> .</li>
<li>checking a configuration string for the existence of a key and retrieving its value. If the key is not in the configuration string, one or more backing configuration strings can be provided, these list all the possible keys with default values. Obviously, if a value is not provided, searching through a long default string is slow.</li>
<li>checking the values of a configuration string against a set of choices. The check is currently done as a sequence of string comparisons. While this in itself is not a huge burden, it proportionally becomes a greater percentage of processing time as the rest of configuration processing performs better.</li>
</ul>
<p>The first compatibility goal is on the calling side, to limit the API explosion that has otherwise happens when we provide a "fast" version of an API. One casualty of adding alternate APIs is that they are lightly tested in C, and often never tested in our Python tests. Our approach is to introduce a new API that can take a configuration string and returns another "compiled" string, that is actually a reference to the binary representation of the configuration string. That string can be used in any API that supports compiled configuration. This means that as APIs are adapted over time to allow a compiled configuration argument, no new changes or structures are needed for the API. Callers can continue to use regular configuration strings, or can pre-compile any configuration string that would be used in a performance path.</p>
<p>A second compatibility goal is with respect to the internal implementation of the API within WiredTiger. These API(s) need to be changed to allow the compiled strings to be used, as well as allow non-compiled strings to be used. These changes should be easy to do and not prone to error.</p>
<h1><a class="anchor" id="compile_conf"></a>
The WT_CONF structure</h1>
<p>The primary structure used by <em>conf</em> is <code>WT_CONF</code>. This provides information about both a single configuration string or a set of configuration strings. That is, in WiredTiger code, it replaces variables or arguments such is <code>const char *config</code> as well as arguments like <code>const char *cfg[]</code>.</p>
<p>To allow for fast checking of keys, we give an integer value to each key used in the entire set of configurations. This is done automatically by the <code>api_config.py</code> script in the <code>dist</code> directory. When WT code asks to get a configuration value for a key, it is now able to use an integer key rather than a string. Previously, code used "read_timestamp" to look up a key, now it uses the integer <code>WT_CONF_ID_checkpoint_read_timestamp</code>. Some of this is hidden from view via macros, so that code that previously did: </p><div class="fragment"><div class="line">WT_ERR(__wt_config_gets_def(session, cfg, <span class="stringliteral">&quot;read_timestamp&quot;</span>, 0, &amp;cval));</div>
</div><!-- fragment --><p>can now do: </p><div class="fragment"><div class="line">WT_ERR(__wt_conf_gets_def(session, conf, read_timestamp, 0, &amp;cval));</div>
</div><!-- fragment --><p>Note that both of these code snippets return <code>cval</code>, which is a <code><a class="el" href="struct_w_t___c_o_n_f_i_g___i_t_e_m.html" title="The configuration information returned by the WiredTiger configuration parsing functions in the WT_EX...">WT_CONFIG_ITEM</a></code>. So any code following this that uses the <code>cval</code> is unchanged. This has allowed us to make mostly mechanical changes on the WiredTiger side, reducing the possibility of errors.</p>
<p>Having one of these <code>WT_CONF_ID_*</code> (or "conf id") integer keys allows the conf functions to access needed information quickly. The <code>WT_CONF</code> struct (which corresponds to <code>conf</code> in the second code snippet above) contains a table that is indexed by this WT_CONF_ID_*. That is here: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>__wt_conf {</div>
<div class="line">    uint8_t value_map[WT_CONF_ID_COUNT]; <span class="comment">/* For each key, a 1-based index into conf_value */</span></div>
<div class="line">    ...</div>
<div class="line">};</div>
</div><!-- fragment --><p> The value of <code>WT_CONF-&gt;value_map</code>[conf_id] for a given <code>conf_id</code> gives us another index, which is called <code>conf_value_index</code> in the code. This value is either <code>0</code>, meaning the key is not in this <code>WT_CONF</code>, or it is an offset into an array of <code>WT_CONF_VALUE</code> entries. Typically, a WT_CONF_VALUE has an embedded <a class="el" href="struct_w_t___c_o_n_f_i_g___i_t_e_m.html" title="The configuration information returned by the WiredTiger configuration parsing functions in the WT_EX...">WT_CONFIG_ITEM</a>, which is what we want. Thus, returning a value from a <code>WT_CONF</code> usually means two indirect references, and then we have a populated <code><a class="el" href="struct_w_t___c_o_n_f_i_g___i_t_e_m.html" title="The configuration information returned by the WiredTiger configuration parsing functions in the WT_EX...">WT_CONFIG_ITEM</a></code> to return.</p>
<p>If we were looking for greater performance, we could have modified this to use one table access by skipping having a <code>value_map</code>. Since there are currently over 300 possible keys in the system, this would have meant having a larger chunk of memory for each compiled string, 12K for starters (300 * ~40 bytes for each WT_CONF_VALUE). But supporting composite keys means that most compiled strings would need some multiple of that value. For now, we use a <code>value_map</code>, this could be reassessed.</p>
<h1><a class="anchor" id="compile_conf_value"></a>
The WT_CONF_VALUE structure</h1>
<p>A <code>WT_CONF_VALUE</code> is a simple struct that has a union along with a discriminant tag. The tag indicates how the union should be interpreted. The union is one of:</p><ul>
<li>a <code><a class="el" href="struct_w_t___c_o_n_f_i_g___i_t_e_m.html" title="The configuration information returned by the WiredTiger configuration parsing functions in the WT_EX...">WT_CONFIG_ITEM</a></code>. This is the typical case, it contains a value ready to return</li>
<li>a sub-configuration index. This will include which <code>WT_CONF</code> in the <code>WT_CONF</code> array to use for subordinate keys.</li>
<li>a <code>WT_CONF_BIND_DESC</code>. This struct contains an offset into WT_SESSION::conf_bindings.values table, that's where the bound value will be found. It also contains info to perform runtime checks on the bound value when we get it.</li>
</ul>
<h1><a class="anchor" id="compile_position_independent"></a>
Position Independent Structures</h1>
<p>The <code>WT_CONF</code> struct is meant to be position independent. A position independent struct can be copied or moved to another memory location without "fixing up" any internal pointers, or allocating new structs. The only pointers in <code>WT_CONF</code> are to items that are immutable and will never change locations, like strings. For example, when we do a compilation, we make a copy of the source string. That copy will always exist for as long as we have the connection open. The <code><a class="el" href="struct_w_t___c_o_n_f_i_g___i_t_e_m.html" title="The configuration information returned by the WiredTiger configuration parsing functions in the WT_EX...">WT_CONFIG_ITEM</a></code> entries that are referenced by <code>WT_CONF</code> have pointers to parts of that immutable string. But the references in <code>WT_CONF</code> to <code><a class="el" href="struct_w_t___c_o_n_f_i_g___i_t_e_m.html" title="The configuration information returned by the WiredTiger configuration parsing functions in the WT_EX...">WT_CONFIG_ITEM</a></code> entries, though, are not pointers. The reference is achieved by using an offset to an adjacent piece of memory.</p>
<p>What if the <code>WT_CONF_VALUE</code> array was not adjacent to the WT_CONF? They could be allocated separately, but then the <code>WT_CONF</code> would need a pointer to where the array was allocated. Then, copying the <code>WT_CONF</code> would probably need a new <code>WT_CONF_VALUE</code> array to be allocated and copied, and the pointer adjusted in the copy. And copies are needed to make changes to a base configuration. When we compile a configuration string, we want to take an (already compiled) WT_CONF for all the default values for that configuration and copy it, and then overwrite it with the values in the configuration string. To do that, we need a fast copy without extra allocations and fix-ups.</p>
<p>Why do we need compilation to be fast anyway? After all, an efficient program will do pre-compiling in advance. The reason is to also efficiently handle any uses of the API that don't use pre-compiled strings. For those uses, we go ahead and pre-compile the given configuration string. This has several advantages:</p><ul>
<li>after pre-compiling, we will always have a single way to get configuration values. Imagine an API that supports pre-compiled strings. Suppose, if we are called with a (non-pre-compiled) configuration string, we leave it as is. Then we would need two mechanisms to access any key in the input configuration. We could pull this off, but it's a bit clumsy.</li>
<li>efficiency. By pre-compiling, we've walked through the config string exactly once, and we never need to walk through it again. This saves us a bunch of time - that is, we get speedups even if callers are not doing explicit pre-compilation.</li>
<li>testing. All of our existing tests are testing the code paths to pre-compile and access the pre-compiled struct. We don't need two modes of testing, or lots of extra test cases.</li>
</ul>
<p>The total size of the <code>WT_CONF</code> struct and its associated <code>WT_CONF_VALUE</code> structs can be totally determined at compile time. This is also true for <code>WT_CONF</code> structs that have subordinate <code>WT_CONF</code> structs, which is used to support composite keys. Subordinate <code>WT_CONF</code> structs appear after the parent <code>WT_CONF</code> struct and before the <code>WT_CONF_VALUE</code> array. Since they each have their own fixed size, but each size may be different, we have, within the <code>WT_CONF</code> struct, an offset of the <code>WT_CONF_VALUE</code> array. The <code>WT_CONF_VALUE_TABLE_ENTRY</code> macro is used to access the <code>WT_CONF_VALUE</code> entries, using the offset.</p>
<h1><a class="anchor" id="compile_composite"></a>
Syntactic Sugar and Composite Keys</h1>
<p>Suppose we have a fictional key <code>"blah"</code>, and we want a slick way to get its associated ID (WT_CONF_ID_blah) while using the syntax: </p><div class="fragment"><div class="line">WT_ERR(__wt_conf_gets_def(session, blah, read_timestamp, 0, &amp;cval));</div>
</div><!-- fragment --><p>Well, we can certainly use identifier pasting (the <code>##</code> operator) via the C pre-processor to accomplish this. That's fine, but...</p>
<p>WiredTiger also makes heavy use of composite keys to reach down into sub-configurations (or "categories"). For example, suppose our fictional configuration string looks like <code>"blah=7,foo=(bar=123,hello=456)"</code> and we want to get the value for <code>foo.bar</code> . How do we identify these multiple parts to our access functions? And note that we have depths of sub-configuration greater than two. Ideally, we want to take code that currently looks like this: </p><div class="fragment"><div class="line">WT_ERR(__wt_config_gets_def(session, cfg, <span class="stringliteral">&quot;foo.bar&quot;</span>, 0, &amp;cval));</div>
</div><!-- fragment --><p>and change it to: </p><div class="fragment"><div class="line">WT_ERR(__wt_conf_gets_def(session, conf, foo.bar, 0, &amp;cval));</div>
</div><!-- fragment --><p>Our solution is to create a const struct in <code>conf.h</code> that contains something like this: </p><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct </span>{</div>
<div class="line">    uint64_t blah;</div>
<div class="line">    ...</div>
<div class="line">    <span class="keyword">struct </span>{</div>
<div class="line">       uint64_t bar;</div>
<div class="line">       ...</div>
<div class="line">    } Foo;</div>
<div class="line">    ...</div>
<div class="line">} WT_CONF_ID_STRUCTURE = {</div>
<div class="line">  {</div>
<div class="line">    WT_CONF_ID_blah,</div>
<div class="line">    ...</div>
<div class="line">    {</div>
<div class="line">       WT_CONF_ID_foo | (WT_CONF_ID_bar &lt;&lt; 16),</div>
<div class="line">       ...</div>
<div class="line">    },</div>
<div class="line">    ...</div>
<div class="line">};</div>
</div><!-- fragment --><p>This is pretty close to our ideal, we need to use capitalization for walking through subordinate structures, like so: </p><div class="fragment"><div class="line">WT_ERR(__wt_conf_gets_def(session, conf, Foo.bar, 0, &amp;cval));</div>
</div><!-- fragment --><p>The capitalization was an unfortunate side effect of having an unregulated, but flexible namespace. For example, <code>"checkpoint"</code> is both a key and a category name.</p>
<p>As you might guess <code>__wt_conf_gets_def</code> is a macro that changes its third argument <code>Foo.bar</code> to <code>WT_CONF_ID_STRUCTURE.Foo.bar</code> . And that in turn is a <code>const</code> value, it takes no space and can be fully evaluated at compile time to be <code>WT_CONF_ID_foo | (WT_CONF_ID_bar &lt;&lt; 16)</code>.</p>
<p>That allows the function that will be called (by the macro) to take a uint64_t arg, whose layers can be peeled off as we are evaluating composite queries. It also means that we have a depth limit of four for subcategories.</p>
<h1><a class="anchor" id="compile_layout"></a>
WT_CONF storage layout</h1>
<p>A <code>WT_CONF</code> and all its sub-configurations fit contiguously in memory. The struct <code>WT_CONF</code> for the configuration in question appears first, followed by the <code>WT_CONF</code> for each sub-configurations, and additional <code>WT_CONF</code> structs for any other subordinate configuration. These effective form a <code>WT_CONF</code> array. Following this array, all the WT_CONF_VALUE structs that are used appear in a single array. To avoid extra calculations during processing, each <code>WT_CONF</code> contains an offset to the slice of the <code>WT_CONF_VALUE</code> array that it uses.</p>
<p>As an example, consider compiling the default configuration string for <code><a class="el" href="struct_w_t___s_e_s_s_i_o_n.html#a7e26b16b26b5870498752322fad790bf" title="Start a transaction in this session.">WT_SESSION::begin_transaction</a></code>. Default configuration strings for every API (compiled or not) are listed in <code>config_def.c</code> . The string for <code>begin_transaction</code> lists all the legal keys and their default value: </p><div class="fragment"><div class="line"><span class="stringliteral">&quot;ignore_prepare=false,isolation=,name=,no_timestamp=false,&quot;</span></div>
<div class="line"><span class="stringliteral">&quot;operation_timeout_ms=0,priority=0,read_timestamp=,&quot;</span></div>
<div class="line"><span class="stringliteral">&quot;roundup_timestamps=(prepared=false,read=false),sync=&quot;</span>,</div>
</div><!-- fragment --><p>Notice that this has a sub-configuration: </p><div class="fragment"><div class="line"><span class="stringliteral">&quot;roundup_timestamps=(prepared=false,read=false)</span></div>
</div><!-- fragment --><p> that will have its own <code>WT_CONF</code> struct. In total, we have two WT_CONF structs. There are a total of eight top level keys, and two keys associated with <code>roundup_timestamps</code>. So we'll have an array of ten WT_CONF_VALUE structs. This looks like:</p>
<div class="image">
<img src="config-comp.png" alt=""/>
</div>
 <p>You can see that <code>value_map</code> is a sparse array; only a small number of its 300 some entries are non-zero. Both value_map arrays are actually the same size, the second one is much more sparse, so the zeroed gaps are larger than they appear in this picture. Each entry in the map is a byte, which currently limits the number of WT_CONF_VALUE array entries to 256.</p>
<p>Let's look at how we would look up <code>read_timestamp</code> in this <code>WT_CONF</code>. We'll always start at the top <code>WT_CONF</code>. <code>WT_CONF_ID_read_timestamp</code> is defined as <code>4</code>, which means we'll look at <code>value_map</code>[4]. That is the entry that has <code>7</code>. We then use <code>7</code> along with the offset to the associated <code>WT_CONF_VALUE</code> array using a 1-based lookup. And that leads us to the <code>WT_CONF_VALUE</code> for <code>read_timestamp</code> . A <code>WT_CONF_VALUE</code> is a union, and its tag indicates that the <code><a class="el" href="struct_w_t___c_o_n_f_i_g___i_t_e_m.html" title="The configuration information returned by the WiredTiger configuration parsing functions in the WT_EX...">WT_CONFIG_ITEM</a></code> part of the union is used. That <code><a class="el" href="struct_w_t___c_o_n_f_i_g___i_t_e_m.html" title="The configuration information returned by the WiredTiger configuration parsing functions in the WT_EX...">WT_CONFIG_ITEM</a></code> is filled in according to the value indicated in the default string, that is, <code>"read_timestamp="</code>. That <code><a class="el" href="struct_w_t___c_o_n_f_i_g___i_t_e_m.html" title="The configuration information returned by the WiredTiger configuration parsing functions in the WT_EX...">WT_CONFIG_ITEM</a></code> is what is returned by the look up.</p>
<p>For a composite key, let's examine looking up <code>roundup_timestamps.read</code>. The definition of <code>WT_CONF_ID_roundup_timestamps</code> is <code>157</code>, the top level <code>value_map</code>[157] has <code>8</code>, that takes us to the eighth <code>WT_CONF_VALUE</code>. Its union tag indicates it has sub-configuration at offset 1. That is, the second <code>WT_CONF</code> in the conf array. <code>WT_CONF_ID_read</code> is <code>159</code>, so now we use the <code>value_map</code> in the second <code>WT_CONF</code>, that takes us to entry 2. We use the offset from the second <code>WT_CONF</code> to finally find the matching <code>WT_CONF_VALUE</code> for <code>roundup_timestamps.read</code> . This is tagged as a <code><a class="el" href="struct_w_t___c_o_n_f_i_g___i_t_e_m.html" title="The configuration information returned by the WiredTiger configuration parsing functions in the WT_EX...">WT_CONFIG_ITEM</a></code>, so that's what we'll return.</p>
<p>When we compile any configuration string for a given API, we always know the total size of the <code>WT_CONF</code> and all of its parts, even without looking at the configuration string. That is because a configuration string constructed by a calling program is always used in conjunction with the set of defaults. So any <code>WT_CONF</code> for compiled string includes the values given by the input string, as well as the values given by the defaults. Using this approach means checking and getting configuration values involves looking at only one data structure. The cost is that any compiled <code>WT_CONF</code> struct maybe large. However, we expect that most programs will only have a small number of pre-compiled strings.</p>
<h1><a class="anchor" id="compile_unbound"></a>
Compiling Unbound Parameters</h1>
<p>Up to now, we've been talking about fixed configuration strings. A more typical case is a configuration string where one or more parts of it may vary from call to call. For example, with begin_transaction, we might want to give each transaction a read_timestamp, and we only know that when we are ready to do the call. The compilation system allows unbound parameters that can later be bound. Currently, there are two kinds of bindings:</p><ul>
<li>strings, represented by "%s"</li>
<li>integers and boolean, represented by "%d"</li>
</ul>
<p>These special values indicate a deferred binding. For example, if we compile the string: </p><div class="fragment"><div class="line"><span class="stringliteral">&quot;ignore_prepare=%d,name=%s,read_timestamp=%d&quot;</span></div>
</div><!-- fragment --><p> we'll need a way to mark these unbound parameters in the <code>WT_CONF</code> struct (discussed below). Before using the compiled string, the API user will call <a class="el" href="struct_w_t___s_e_s_s_i_o_n.html#aedd139d6424440d5300e88c4fa061f41" title="Bind values for a compiled configuration.">WT_SESSION::bind_configuration</a> with the actual values. Using the above compiled string, the caller might say: </p><div class="fragment"><div class="line">session-&gt;<a class="code" href="struct_w_t___s_e_s_s_i_o_n.html#aedd139d6424440d5300e88c4fa061f41">bind_configuration</a>(session, compiled_config_string,</div>
<div class="line">   1,                    <span class="comment">/* ignore_prepare, boolean &#39;true&#39; */</span></div>
<div class="line">   <span class="stringliteral">&quot;txn_name123&quot;</span>,        <span class="comment">/* name */</span></div>
<div class="line">   0x1234);              <span class="comment">/* read_timestamp */</span></div>
</div><!-- fragment --><p>The binding values are first checked for validity if needed, just as a configuration string checks its values. The values are then put into the session in an array of <code><a class="el" href="struct_w_t___c_o_n_f_i_g___i_t_e_m.html" title="The configuration information returned by the WiredTiger configuration parsing functions in the WT_EX...">WT_CONFIG_ITEM</a></code>. The ordering of values given in the <code>bind_configuration</code> must match the order of the <code>''</code> entries given in the configuration string.</p>
<p>We said we need a way to mark the unbound parameters in the <code>WT_CONF</code> during compilation. That is done in the associated <code>WT_CONF_VALUE</code> struct. It has a tag indicating a binding, and thus contains a <code>WT_CONF_BIND_DESC</code> struct. This struct has the offset into the session's array of bound values. Also, an ordered list of pointers to these WT_CONF_BIND_DESC structs makes it easy to find the right binding during the <code>bind_configuration</code> call.</p>
<p>This is one of the few times we allow pointers in <code>WT_CONF</code>. It is safe because unbound parameters are not used internally by WiredTiger. That is, a <code>WT_CONF</code> built for a default configuration has no unbound parameters, and thus has no pointers. So it can be freely copied when we create a <code>WT_CONF</code> as a basis for a user's request to compile a configuration string.</p>
<h1><a class="anchor" id="compile_bind"></a>
Binding Parameters</h1>
<p>The <a class="el" href="struct_w_t___s_e_s_s_i_o_n.html#aedd139d6424440d5300e88c4fa061f41" title="Bind values for a compiled configuration.">WT_SESSION::bind_configuration</a> call will be used to fill entries in an <code>array</code> encapsulated in the session with the <code>WT_CONF_BINDINGS</code> struct. Each element of this array has two entries, a pointer to the <code>WT_CONF_BIND_DESC</code> descriptor used and the <code><a class="el" href="struct_w_t___c_o_n_f_i_g___i_t_e_m.html" title="The configuration information returned by the WiredTiger configuration parsing functions in the WT_EX...">WT_CONFIG_ITEM</a></code>.</p>
<p>The <a class="el" href="struct_w_t___s_e_s_s_i_o_n.html#aedd139d6424440d5300e88c4fa061f41" title="Bind values for a compiled configuration.">WT_SESSION::bind_configuration</a> does the following steps.</p><ul>
<li>Use the first argument to find the <code>WT_CONF</code> struct we are binding to. See <a class="el" href="arch-config-compile.html#compile_returned_string">The Compiled String</a>.</li>
<li>Within <code>WT_CONF</code>, get the list of unbound parameters <code>WT_CONF-&gt;binding_descriptions</code>.</li>
<li>Walk through the variable arguments, matching each to a binding_description.</li>
<li>For each binding_description, get a variable argument of the matching type and: &ndash; fill the next <a class="el" href="struct_w_t___c_o_n_f_i_g___i_t_e_m.html" title="The configuration information returned by the WiredTiger configuration parsing functions in the WT_EX...">WT_CONFIG_ITEM</a> in the session array, along with <code>WT_CONF_BIND_DESC</code> pointer from the WT_CONF-&gt;binding_descriptions array. &ndash; advance the position pointer in the session to the next array entry for parameter bindings.</li>
</ul>
<p>At runtime, if we look up the key in question, in the WT_CONF_VALUE union, we would find a <code>WT_CONF_BIND_DESC</code>, and know what offset in the session array to find the needed <code><a class="el" href="struct_w_t___c_o_n_f_i_g___i_t_e_m.html" title="The configuration information returned by the WiredTiger configuration parsing functions in the WT_EX...">WT_CONFIG_ITEM</a></code>. For sanity, we can check that the <code>WT_CONF_BIND_DESC</code> pointer in the array matches the union entry we are on.</p>
<h1><a class="anchor" id="compile_scripts"></a>
Scripts Supporting Configuration Compilation</h1>
<p>In <code>dist</code>, API methods that support compilation are marked in <code>api_data.py</code>. <code>api_config.py</code> contains functions that use the data in <code>api_data.py</code> to create or modify files in <code>src/include</code>, including <code>config.h</code> and <code>conf.h</code> . Knowledge of the configuration strings is used to set up initialized data structures that are used for compilation, argument checking, and default values.</p>
<h1><a class="anchor" id="compile_initial"></a>
Initial Pre-Compilation</h1>
<p>For any API method that supports compilation, we do pre-compilation when a connection is opened. That is, we compile the configuration string that has all the default values listed, and store the result. The gives us a ready made "default" <code>WT_CONF</code>, that is stored in the connection. This is used for a common case when the API is called with no configuration string. It also is a basis for when we compile a configuration string.</p>
<p>Compiling a configuration string starts by knowing the size of the WT_CONF struct. We know the size of the default <code>WT_CONF</code>, derived from how many sub-configurations it has, and how many total keys it has. Our compiled configuration is the same size, so we allocate storage for it, and do a memory copy of the default <code>WT_CONF</code>. Then we can fill any parts that change.</p>
<h1><a class="anchor" id="compile_returned_string"></a>
The Compiled String</h1>
<p>A call to WT_SESSION::compile_configuration compiles a configuration string and returns a <code>const char *</code> that can be used by the caller in place of a compilation string. When WiredTiger compiles the string a we've described, we end up with a <code>WT_CONF</code> struct, and we'd like to return that to the caller. For debugging purposes, we'd like what we return to look like a string.</p>
<p>Our current implementation returns a special string that is an offset into a dummy array associated with the <a class="el" href="struct_w_t___c_o_n_n_e_c_t_i_o_n.html" title="A connection to a WiredTiger database.">WT_CONNECTION</a>. That is, we create an string of size 1024 and put it into <code>WT_CONNECTION-&gt;conf_dummy</code>. When the application calls WT_SESSION::compile_configuration to compile a string the Nth time, we put a pointer to the compiled <code>WT_CONF</code> into entry <em>N</em> of the <code>WT_CONNECTION-&gt;conf_array</code> struct, and return <code>&amp;WT_CONNECTION-&gt;conf_dummy[N]</code>. When the application uses that string later, we can easily recognize that it is an offset into the <code>conf_dummy</code> array, and find the needed <code>WT_CONF</code>.</p>
<h1><a class="anchor" id="compile_scoped_id"></a>
No Scoped Identifiers</h1>
<p>Above, we state that we have a separate identifier for every key used in the configuration system, that's more than 300 keys. Data structures could be smaller, and possibly made faster, if we had a smaller number of keys in play. Since each API might have only a small fraction of keys, perhaps a dozen or so, might it make sense to scope the identifiers. For example, instead of having:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define WT_CONF_ID_sync 118</span></div>
</div><!-- fragment --><p> could we not have something like: </p><div class="fragment"><div class="line"><span class="preprocessor">#define WT_CONF_ID_begin_transaction_sync 9</span></div>
<div class="line">...</div>
<div class="line">#define WT_CONF_ID_checkpoint_sync 13</div>
<div class="line">...</div>
<div class="line">#define WT_CONF_ID_flush_tier_sync 4</div>
</div><!-- fragment --><p> These scoped numbers would only need to be unique within their own API, so they could be a lot smaller.</p>
<p>This approach could work in some cases, but there are places in WiredTiger where certain sets of configuration keys are known to multiple APIs. There are then shared utility functions that manage the configuration parsing of these sets of keys. These utility functions currently take configuration string arguments, and would be converted over to using <code>WT_CONF</code> arguments. But such utility functions aren't necessarily scoped, for example, they may be used by multiple APIs. This is a case where we <em>would</em> want values between multiple APIs to be the same. There are workarounds for this, but it rapidly becomes messy. For simplicity, we went with identifiers that have no scope. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div class="ttc" id="astruct_w_t___s_e_s_s_i_o_n_html_aedd139d6424440d5300e88c4fa061f41"><div class="ttname"><a href="struct_w_t___s_e_s_s_i_o_n.html#aedd139d6424440d5300e88c4fa061f41">WT_SESSION::bind_configuration</a></div><div class="ttdeci">int bind_configuration(WT_SESSION *session, const char *compiled,...)</div><div class="ttdoc">Bind values for a compiled configuration.</div></div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">Reference Guide</a></li><li class="navelem"><a class="el" href="arch-index.html">WiredTiger Architecture Guide</a></li><li class="navelem"><a class="el" href="arch-toc-api.html">API</a></li>
    <li class="footer">Copyright (c) 2008-present MongoDB, Inc.  All rights reserved.  Contact <a href="mailto:info@wiredtiger.com">info@wiredtiger.com</a> for more information.</li>
  </ul>
</div>
</body>
</html>
