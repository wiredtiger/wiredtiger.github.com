<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>WiredTiger: Testing with LLVM LibFuzzer</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="sorttable.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="wiredtiger.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://wiredtiger.com/"><img alt="Logo" src="LogoFinal-header.png" alt="WiredTiger" /></a></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Version 10.0.2</span>
   </div>
   <div id="projectbrief"><!-- 10.0.2 --></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<div class="banner">
  <a href="https://github.com/wiredtiger/wiredtiger">Fork me on GitHub</a>
  <a class="last" href="http://groups.google.com/group/wiredtiger-users">Join my user group</a>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('tool-libfuzzer.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Testing with LLVM LibFuzzer </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md11"></a>
Building and running an LLVM LibFuzzer fuzzer</h1>
<p>LLVM LibFuzzer is an in-process, coverage-guided, evolutionary fuzzing engine. It feeds a series of fuzzed inputs via a user-provided "target" function and attempts to trigger crashes, memory bugs and undefined behavior.</p>
<p>A fuzzer is a program that consists of the aforementioned target function linked against the LibFuzzer runtime. The LibFuzzer runtime provides the entry-point to the program and repeatedly calls the target function with generated inputs.</p>
<h2><a class="anchor" id="autotoc_md12"></a>
Step 1: Configure with Clang as your C compiler and enable LibFuzzer</h2>
<p>Support for LibFuzzer is implemented as a compiler flag in Clang. WiredTiger's build configuration checks whether the compiler in use supports <code>-fsanitize=fuzzer-no-link</code> and if so, elects to build the tests.</p>
<p>Compiling with Clang's Address Sanitizer isn't mandatory but it is recommended since fuzzing often exposes memory bugs.</p>
<div class="fragment"><div class="line">$ mkdir build</div>
<div class="line">$ cd build</div>
<div class="line">$ cmake -DENABLE_LLVM=1 -DCMAKE_TOOLCHAIN_FILE=../cmake/toolchains/clang.cmake -DCLANG_C_VERSION=<span class="stringliteral">&quot;8&quot;</span> -DCLANG_CXX_VERSION=<span class="stringliteral">&quot;8&quot;</span> -DCMAKE_BUILD_TYPE=ASan ../.</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md13"></a>
Step 2: Build as usual</h2>
<div class="fragment"><div class="line">$ make</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md14"></a>
Step 3: Run a fuzzer</h2>
<p>Each fuzzer is a program under <code>build/test/fuzz/</code>. WiredTiger provides the <code>test/fuzz/fuzz_run.sh</code> script to quickly get started using a fuzzer. It performs a limited number of runs, automatically cleans up after itself in between runs and provides a sensible set of parameters which users can add to. For example:</p>
<div class="fragment"><div class="line">$ cd build/test/fuzz/</div>
<div class="line">$ bash ../../../test/fuzz/fuzz_run.sh ./test_fuzz_modify</div>
</div><!-- fragment --><p>In general the usage is:</p>
<div class="fragment"><div class="line">fuzz_run.sh &lt;fuzz-test-binary&gt; [fuzz-test-args]</div>
</div><!-- fragment --><p>Each fuzzer will produce a few outputs:</p>
<ul>
<li><code>crash-&lt;input-hash&gt;</code>: If an error occurs, a file will be produced containing the input that crashed the target.</li>
<li><code>fuzz-N.log</code>: The LibFuzzer log for worker N. This is just an ID that LibFuzzer assigns to each worker ranging from 0 =&gt; the number of workers - 1.</li>
<li><code>WT_TEST_&lt;pid&gt;</code>: The home directory for a given worker process.</li>
<li><code>WT_TEST_&lt;pid&gt;.profraw:</code> If the fuzzer is running with Clang coverage (more on this later), files containing profiling data for a given worker will be produced. These will be used by <code>fuzz_coverage</code>.</li>
</ul>
<h3><a class="anchor" id="autotoc_md15"></a>
Corpus</h3>
<p>LibFuzzer is a coverage based fuzzer meaning that it notices when a particular input hits a new code path and adds it to a corpus of interesting data inputs. It then uses existing data in the corpus to mutate and come up with new inputs.</p>
<p>While LibFuzzer will automatically add to its corpus when it finds an interesting input, some fuzz targets (especially those that expect data in a certain format) require a corpus to start things off in order to be effective. The fuzzer <code>fuzz_config</code> is one example of this as it expects its data sliced with a separator so the fuzzing engine needs some examples to guide it. The corpus is supplied as the first positional argument to both <code>fuzz_run.sh</code> and the underlying fuzzer itself. For example:</p>
<div class="fragment"><div class="line">$ cd build/test/fuzz/</div>
<div class="line">$ bash ../../../test/fuzz/fuzz_run.sh ./test_fuzz_config ../../../test/fuzz/config/corpus/</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md16"></a>
Implementing an LLVM LibFuzzer fuzzer</h1>
<h2><a class="anchor" id="autotoc_md17"></a>
Overview</h2>
<p>Creating a fuzzer with LLVM LibFuzzer requires an implementation of a single function called <code>LLVMFuzzerTestOneInput</code>. It has the following prototype:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> LLVMFuzzerTestOneInput(<span class="keyword">const</span> uint8_t *data, <span class="keywordtype">size_t</span> size);</div>
</div><!-- fragment --><p>When supplied with the <code>-fsanitize=fuzzer</code> flag, Clang will use its own <code>main</code> function and repeatedly call the provided <code>LLVMFuzzerTestOneInput</code> with various inputs. There is a lot of information online about best practices when writing fuzzing targets but to summarize, the requirements are much like those for writing unit tests: they should be fast, deterministic and stateless (as possible). The <a href="https://llvm.org/docs/LibFuzzer.html">LLVM LibFuzzer reference page</a> is a good place to start to learn more.</p>
<h2><a class="anchor" id="autotoc_md18"></a>
Fuzz Utilities</h2>
<p>WiredTiger has a small fuzz utilities library containing common functionality required for writing fuzz targets. Most of the important functions here are about manipulating fuzz input into something that targets can use with the WiredTiger API.</p>
<h3><a class="anchor" id="autotoc_md19"></a>
Slicing inputs</h3>
<p>If the function that a target is testing can accept a binary blob of data, then the target will be straightforward as it'll more or less just pass the input to the function under test. But for functions that require more structured input, this can pose a challenge. As an example, the <code>fuzz_config</code> target requires two inputs that can be variable length: a configuration string and a key to search for. In order to do this, the target can use an arbitrary separator sequence to split the input into multiple parts with the following API:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>{</div>
<div class="line">    <span class="keyword">const</span> uint8_t **slices;</div>
<div class="line">    <span class="keywordtype">size_t</span> *sizes;</div>
<div class="line">    <span class="keywordtype">size_t</span> num_slices;</div>
<div class="line">} FUZZ_SLICED_INPUT;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> fuzzutil_sliced_input_init(FUZZ_SLICED_INPUT *input, <span class="keyword">const</span> uint8_t *data, <span class="keywordtype">size_t</span> size,</div>
<div class="line">  <span class="keyword">const</span> uint8_t *sep, <span class="keywordtype">size_t</span> sep_size, <span class="keywordtype">size_t</span> req_slices);</div>
<div class="line"><span class="keywordtype">void</span> fuzzutil_sliced_input_free(FUZZ_SLICED_INPUT *input);</div>
</div><!-- fragment --><p> Using this API, the target can supply a data buffer, a separator sequence and the number of inputs it needs. If it doesn't find the right number of separators in the provided input, <code>fuzzutil_sliced_input_init</code> will return <code>false</code> and the target should return out of the <code>LLVMFuzzerTestOneInput</code> function. While this may seem like the target will reject a lot of input, the fuzzing engine is able to figure out (especially if an initial corpus is supplied), that inputs with the right number of separators tend to yield better code coverage and will bias its generated inputs towards this format.</p>
<p>In <code>fuzz_config</code>, we use the <code></code>| character as a separator since this cannot appear in a configuration string. So an input separated correctly will look like this:</p>
<div class="fragment"><div class="line">allocation_size|key_format=u,value_format=u,allocation_size=512,log=(enabled)</div>
</div><!-- fragment --><p>But for data where there is no distinct character that can be used as a sentinel, we can provide a byte sequence such as <code>0xdeadbeef</code>. So in that case, a valid input may look like this:</p>
<div class="fragment"><div class="line">0xaa 0xaa 0xde 0xad 0xbe 0xef 0xff 0xff</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md20"></a>
Viewing code coverage for an LLVM LibFuzzer fuzzer</h1>
<p>After implementing a new fuzzing target, developers typically want to validate that it's doing something useful. If the fuzzer is not producing failures, it's either because the code under test is robust or the fuzzing target isn't doing a good job of exercising different code paths.</p>
<h2><a class="anchor" id="autotoc_md21"></a>
Step 1: Configure your build to compile with Clang coverage</h2>
<p>In order to view code coverage information, the build will need to be configured with the <code>-fprofile-instr-generate</code> and <code>-fcoverage-mapping</code> flags to tell Clang to instrument WiredTiger with profiling information. It's important that these are added to both the <code>CFLAGS</code> and <code>LINKFLAGS</code> variables.</p>
<div class="fragment"><div class="line">$ mkdir build</div>
<div class="line">$ cd build</div>
<div class="line">$ cmake -DENABLE_LLVM=1 -DCMAKE_TOOLCHAIN_FILE=../cmake/toolchains/clang.cmake -DCLANG_C_VERSION=<span class="stringliteral">&quot;8&quot;</span> -DCLANG_CXX_VERSION=<span class="stringliteral">&quot;8&quot;</span> -DCMAKE_BUILD_TYPE=Coverage ../.</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md22"></a>
Step 2: Build and run fuzzer</h2>
<p>Build and invoke <code>fuzz_run.sh</code> for the desired fuzzer as described in the section above.</p>
<h2><a class="anchor" id="autotoc_md23"></a>
Step 3: Generate code coverage information</h2>
<p>After running the fuzzer with Clang coverage switched on, there should be a number of <code>profraw</code> files in the working directory.</p>
<p>Those files contain the raw profiling data however, some post-processing is required to get it into a readable form. WiredTiger provides a script called <code>fuzz_coverage.sh</code> that handles this. It expects to be called from the same directory that the fuzzer was executed in.</p>
<div class="fragment"><div class="line">$ cd build/test/fuzz</div>
<div class="line">$ bash ../../../test/fuzz/fuzz_coverage.sh ./test_fuzz_modify</div>
</div><!-- fragment --><p>In general the usage is:</p>
<div class="fragment"><div class="line">fuzz_coverage.sh &lt;fuzz-test-binary&gt;</div>
</div><!-- fragment --><p>The <code>fuzz_coverage.sh</code> script produces a few outputs:</p>
<ul>
<li><code>&lt;fuzz-test-binary&gt;_cov.txt:</code> A coverage report in text format. It can be inspected with the <code>less</code> command and searched for functions of interest. The numbers on the left of each line of code indicate how many times they were hit in the fuzzer.</li>
<li><code>&lt;fuzz-test-binary&gt;_cov.html:</code> A coverage report in html format. If a web browser is available, this might be a nicer way to visualize the coverage.</li>
</ul>
<p>The <code>fuzz_coverage.sh</code> script uses a few optional environment variables to modify its behavior.</p>
<ul>
<li><code>PROFDATA_BINARY:</code> The binary used to merge the profiling data. The script defaults to using <code>llvm-profdata</code>.</li>
<li><code>COV_BINARY:</code> The binary used to generate coverage information. The script defaults to using <code>llvm-cov</code>.</li>
</ul>
<p>For consistency, the script should use the <code>llvm-profdata</code> and <code>llvm-cov</code> binaries from the same LLVM release as the <code>clang</code> compiler used to build with. In the example above, <code>clang-8</code> was used in the configuration, so the corresponding <code>fuzz_coverage.sh</code> invocation should look like this:</p>
<div class="fragment"><div class="line">$ PROFDATA_BINARY=llvm-profdata-8 COV_BINARY=llvm-cov-8 bash ../../../test/fuzz/fuzz_coverage.sh ./fuzz_modify</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">Reference Guide</a></li><li class="navelem"><a class="el" href="tool-index.html">Tools and Techniques</a></li>
    <li class="footer">Copyright (c) 2008-present MongoDB, Inc.  All rights reserved.  Contact <a href="mailto:info@wiredtiger.com">info@wiredtiger.com</a> for more information.</li>
  </ul>
</div>
</body>
</html>
