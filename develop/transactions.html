<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>WiredTiger: Transactions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="wiredtiger.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://wiredtiger.com/"><img alt="Logo" src="LogoFinal-header.png" alt="WiredTiger" /></a></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Version 10.0.0</span>
   </div>
   <div id="projectbrief"><!-- 10.0.0 --></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<div class="banner">
  <a href="https://github.com/wiredtiger/wiredtiger">Fork me on GitHub</a>
  <a class="last" href="http://groups.google.com/group/wiredtiger-users">Join my user group</a>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('transactions.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Transactions </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="transactions_acid"></a>
ACID properties</h1>
<p>Transactions provide a powerful abstraction for multiple threads to operate on data concurrently because they have the following properties:</p>
<ul>
<li>Atomicity: all or none of a transaction is completed.</li>
<li>Consistency: if each transaction maintains some property when considered separately, then the combined effect of executing the transactions concurrently will maintain the same property.</li>
<li>Isolation: developers can reason about transactions as if they run single-threaded.</li>
<li>Durability: once a transaction commits, its updates cannot be lost.</li>
</ul>
<p>WiredTiger supports transactions with the following caveats to the ACID properties:</p>
<ul>
<li>the maximum level of isolation supported is snapshot isolation. See <a class="el" href="transactions.html#transaction_isolation">Isolation levels</a> for more details.</li>
<li>transactional updates are made durable by a combination of checkpoints and logging. See <a class="el" href="checkpoint.html">Checkpoint durability</a> for information on checkpoint durability and <a class="el" href="durability.html">Commit-level durability</a> for information on commit-level durability.</li>
<li>each transaction's uncommitted changes must fit in memory: for efficiency, WiredTiger does not write to the log until a transaction commits.</li>
</ul>
<h1><a class="anchor" id="transactions_api"></a>
Transactional API</h1>
<p>In WiredTiger, transaction operations are methods off the <a class="el" href="struct_w_t___s_e_s_s_i_o_n.html" title="All data operations are performed in the context of a WT_SESSION. ">WT_SESSION</a> class.</p>
<p>Applications call <a class="el" href="struct_w_t___s_e_s_s_i_o_n.html#a7e26b16b26b5870498752322fad790bf" title="Start a transaction in this session. ">WT_SESSION::begin_transaction</a> to start a new transaction. Operations subsequently performed using that <a class="el" href="struct_w_t___s_e_s_s_i_o_n.html" title="All data operations are performed in the context of a WT_SESSION. ">WT_SESSION</a> handle, including operations on any cursors open in that <a class="el" href="struct_w_t___s_e_s_s_i_o_n.html" title="All data operations are performed in the context of a WT_SESSION. ">WT_SESSION</a> handle (whether opened before or after the <a class="el" href="struct_w_t___s_e_s_s_i_o_n.html#a7e26b16b26b5870498752322fad790bf" title="Start a transaction in this session. ">WT_SESSION::begin_transaction</a> call), are part of the transaction and their effects committed by calling <a class="el" href="struct_w_t___s_e_s_s_i_o_n.html#a712226eca5ade5bd123026c624468fa2" title="Commit the current transaction. ">WT_SESSION::commit_transaction</a>, or discarded by calling <a class="el" href="struct_w_t___s_e_s_s_i_o_n.html#ab45f521464ad9e54d9b15efc2ffe20a1" title="Roll back the current transaction. ">WT_SESSION::rollback_transaction</a>. Applications that use <a class="el" href="transactions.html#transaction_timestamps">Application-specified Transaction Timestamps</a> can utilize the <a class="el" href="struct_w_t___s_e_s_s_i_o_n.html#a96b8a369610c8cbb08b8a7c504fd1008" title="Prepare the current transaction. ">WT_SESSION::prepare_transaction</a> API as a basis for implementing a two phase commit protocol.</p>
<p>If <a class="el" href="struct_w_t___s_e_s_s_i_o_n.html#a712226eca5ade5bd123026c624468fa2" title="Commit the current transaction. ">WT_SESSION::commit_transaction</a> returns an error for any reason, the transaction was rolled back, not committed.</p>
<p>When transactions are used, data operations can encounter a conflict and fail with the <a class="el" href="group__wt.html#ga5ee3c6fcd074e11efd118f3e68e91db8" title="Conflict between concurrent operations. ">WT_ROLLBACK</a> error. If this error occurs, transactions should be rolled back with <a class="el" href="struct_w_t___s_e_s_s_i_o_n.html#ab45f521464ad9e54d9b15efc2ffe20a1" title="Roll back the current transaction. ">WT_SESSION::rollback_transaction</a> and the operation retried.</p>
<p>The <a class="el" href="struct_w_t___s_e_s_s_i_o_n.html#ab45f521464ad9e54d9b15efc2ffe20a1" title="Roll back the current transaction. ">WT_SESSION::rollback_transaction</a> method implicitly resets all cursors in the session as if the <a class="el" href="struct_w_t___c_u_r_s_o_r.html#afc1b42c22c9c85e1ba08ce3b34437565" title="Reset the cursor. ">WT_CURSOR::reset</a> method was called, discarding any cursor position as well as any key and value.</p>
<div class="fragment"><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Cursors may be opened before or after the transaction begins, and in either case, subsequent</span></div><div class="line"><span class="comment">     * operations are included in the transaction. Opening cursors before the transaction begins</span></div><div class="line"><span class="comment">     * allows applications to cache cursors and use them for multiple operations.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    error_check(session-&gt;open_cursor(session, <span class="stringliteral">&quot;table:mytable&quot;</span>, NULL, NULL, &amp;cursor));</div><div class="line">    error_check(session-&gt;begin_transaction(session, NULL));</div><div class="line"></div><div class="line">    cursor-&gt;set_key(cursor, <span class="stringliteral">&quot;key&quot;</span>);</div><div class="line">    cursor-&gt;set_value(cursor, <span class="stringliteral">&quot;value&quot;</span>);</div><div class="line">    <span class="keywordflow">switch</span> (cursor-&gt;update(cursor)) {</div><div class="line">    <span class="keywordflow">case</span> 0: <span class="comment">/* Update success */</span></div><div class="line">        error_check(session-&gt;commit_transaction(session, NULL));</div><div class="line">        <span class="comment">/*</span></div><div class="line"><span class="comment">         * If commit_transaction succeeds, cursors remain positioned; if commit_transaction fails,</span></div><div class="line"><span class="comment">         * the transaction was rolled-back and all cursors are reset.</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">    <span class="keywordflow">case</span> <a class="code" href="group__wt.html#ga5ee3c6fcd074e11efd118f3e68e91db8">WT_ROLLBACK</a>: <span class="comment">/* Update conflict */</span></div><div class="line">    <span class="keywordflow">default</span>:          <span class="comment">/* Other error */</span></div><div class="line">        error_check(session-&gt;rollback_transaction(session, NULL));</div><div class="line">        <span class="comment">/* The rollback_transaction call resets all cursors. */</span></div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Cursors remain open and may be used for multiple transactions.</span></div><div class="line"><span class="comment">     */</span></div></div><!-- fragment --> <h1><a class="anchor" id="transactions_implicit"></a>
Implicit transactions</h1>
<p>If a cursor is used when no explicit transaction is active in a session, reads are performed at the isolation level of the session, set with the <code>isolation</code> key to <a class="el" href="struct_w_t___c_o_n_n_e_c_t_i_o_n.html#adad5965cd4a60f65b5ac01f7ca6d1fc0" title="Open a session. ">WT_CONNECTION::open_session</a>, and successful updates are automatically committed before the update operation returns.</p>
<p>Any operation consisting of multiple related updates should be enclosed in an explicit transaction to ensure the updates are applied atomically.</p>
<p>If an implicit transaction successfully commits, the cursors in the <a class="el" href="struct_w_t___s_e_s_s_i_o_n.html" title="All data operations are performed in the context of a WT_SESSION. ">WT_SESSION</a> remain positioned. If an implicit transaction fails, all cursors in the <a class="el" href="struct_w_t___s_e_s_s_i_o_n.html" title="All data operations are performed in the context of a WT_SESSION. ">WT_SESSION</a> are reset, as if <a class="el" href="struct_w_t___c_u_r_s_o_r.html#afc1b42c22c9c85e1ba08ce3b34437565" title="Reset the cursor. ">WT_CURSOR::reset</a> were called, discarding any position or key/value information they may have.</p>
<p>See <a class="el" href="cursors.html#cursors_transactions">Cursors and Transactions</a> for more information.</p>
<h1><a class="anchor" id="transactions_concurrency"></a>
Concurrency control</h1>
<p>WiredTiger uses optimistic concurrency control algorithms. This avoids the bottleneck of a centralized lock manager and ensures transactional operations do not block: reads do not block writes, and vice versa.</p>
<p>Further, writes do not block writes, although concurrent transactions updating the same value will fail with <a class="el" href="group__wt.html#ga5ee3c6fcd074e11efd118f3e68e91db8" title="Conflict between concurrent operations. ">WT_ROLLBACK</a>. Some applications may benefit from application-level synchronization to avoid repeated attempts to rollback and update the same value.</p>
<p>Operations in transactions may also fail with the <a class="el" href="group__wt.html#ga5ee3c6fcd074e11efd118f3e68e91db8" title="Conflict between concurrent operations. ">WT_ROLLBACK</a> error if some resource cannot be allocated after repeated attempts. For example, if the cache is not large enough to hold the updates required to satisfy transactional readers, an operation may fail and return <a class="el" href="group__wt.html#ga5ee3c6fcd074e11efd118f3e68e91db8" title="Conflict between concurrent operations. ">WT_ROLLBACK</a>.</p>
<h1><a class="anchor" id="transaction_isolation"></a>
Isolation levels</h1>
<p>WiredTiger supports <code>read-uncommitted</code>, <code>read-committed</code> and <code>snapshot</code> isolation levels; the default isolation level is <code>read-committed</code>.</p>
<ul>
<li><code>read-uncommitted</code>: Transactions can see changes made by other transactions before those transactions are committed. Dirty reads, non-repeatable reads and phantoms are possible.</li>
<li><code>read-committed</code>: Transactions cannot see changes made by other transactions before those transactions are committed. Dirty reads are not possible; non-repeatable reads and phantoms are possible. Committed changes from concurrent transactions become visible when no cursor is positioned in the read-committed transaction.</li>
<li><code>snapshot</code>: Transactions read the versions of records committed before the transaction started. Dirty reads and non-repeatable reads are not possible; phantoms are possible.<br />
<br />
 Snapshot isolation is a strong guarantee, but not equivalent to a single-threaded execution of the transactions, known as serializable isolation. Concurrent transactions T1 and T2 running under snapshot isolation may both commit and produce a state that neither (T1 followed by T2) nor (T2 followed by T1) could have produced, if there is overlap between T1's reads and T2's writes, and between T1's writes and T2's reads.</li>
</ul>
<p>The transaction isolation level can be configured on a per-transaction basis:</p>
<div class="fragment"><div class="line">    <span class="comment">/* A single transaction configured for snapshot isolation. */</span></div><div class="line">    error_check(session-&gt;open_cursor(session, <span class="stringliteral">&quot;table:mytable&quot;</span>, NULL, NULL, &amp;cursor));</div><div class="line">    error_check(session-&gt;begin_transaction(session, <span class="stringliteral">&quot;isolation=snapshot&quot;</span>));</div><div class="line">    cursor-&gt;set_key(cursor, <span class="stringliteral">&quot;some-key&quot;</span>);</div><div class="line">    cursor-&gt;set_value(cursor, <span class="stringliteral">&quot;some-value&quot;</span>);</div><div class="line">    error_check(cursor-&gt;update(cursor));</div><div class="line">    error_check(session-&gt;commit_transaction(session, NULL));</div></div><!-- fragment --><p> Additionally, the default transaction isolation can be configured and re-configured on a per-session basis:</p>
<div class="fragment"><div class="line">    <span class="comment">/* Open a session configured for read-uncommitted isolation. */</span></div><div class="line">    error_check(conn-&gt;open_session(conn, NULL, <span class="stringliteral">&quot;isolation=read-uncommitted&quot;</span>, &amp;session));</div></div><!-- fragment --> <div class="fragment"><div class="line">    <span class="comment">/* Re-configure a session for snapshot isolation. */</span></div><div class="line">    error_check(session-&gt;reconfigure(session, <span class="stringliteral">&quot;isolation=snapshot&quot;</span>));</div></div><!-- fragment --> <h1><a class="anchor" id="transaction_timestamps"></a>
Application-specified Transaction Timestamps</h1>
<h2><a class="anchor" id="timestamp_overview"></a>
Timestamp overview</h2>
<p>Some applications have their own notion of time, including an expected commit order for transactions that may be inconsistent with the order assigned by WiredTiger. We assume applications can represent their notion of a timestamp as an unsigned 64-bit integral value that generally increases over time. For example, a counter could be incremented to generate transaction timestamps, if that is sufficient for the application.</p>
<p>Applications can assign explicit commit timestamps to transactions, then read "as of" a timestamp. The timestamp mechanism operates in parallel with WiredTiger's internal transaction ID management. It is recommended that once timestamps are in use for a particular table, all subsequent updates also use timestamps.</p>
<h2><a class="anchor" id="timestamp_transactions"></a>
Using transactions with timestamps</h2>
<p>Applications that use timestamps will generally provide a timestamp at WT_SESSION::transaction_commit that will be assigned to all updates that are part of the transaction. WiredTiger also provides the ability to set a different commit timestamp for different updates in a single transaction. This can be done by calling <a class="el" href="struct_w_t___s_e_s_s_i_o_n.html#aa449082ce4de7ee86a773595c416a69f" title="Set a timestamp on a transaction. ">WT_SESSION::timestamp_transaction</a> repeatedly to set a new commit timestamp between a set of updates for the current transaction. This gives the ability to commit updates with different read "as of" timestamps in a single transaction.</p>
<p>Setting a read timestamp in <a class="el" href="struct_w_t___s_e_s_s_i_o_n.html#a7e26b16b26b5870498752322fad790bf" title="Start a transaction in this session. ">WT_SESSION::begin_transaction</a> forces a transaction to run at snapshot isolation and ignore any commits with a newer timestamp.</p>
<p>Commit timestamps cannot be set in the past of any read timestamp that has been used. This is enforced by assertions in diagnostic builds, if applications violate this rule, data consistency can be violated.</p>
<p>The commits to a particular data item must be performed in timestamp order. If applications violate this rule, data consistency can be violated. Committing an update without a timestamp truncates the update's timestamp history and limits repeatable reads: no earlier version of the update will be returned regardless of the setting of the read timestamp.</p>
<p>The <a class="el" href="struct_w_t___s_e_s_s_i_o_n.html#a96b8a369610c8cbb08b8a7c504fd1008" title="Prepare the current transaction. ">WT_SESSION::prepare_transaction</a> API is designed to be used in conjunction with timestamps and assigns a prepare timestamp to the transaction, which will be used for visibility checks until the transaction is committed or aborted. Once a transaction has been prepared the only other operations that can be completed are <a class="el" href="struct_w_t___s_e_s_s_i_o_n.html#a712226eca5ade5bd123026c624468fa2" title="Commit the current transaction. ">WT_SESSION::commit_transaction</a> or <a class="el" href="struct_w_t___s_e_s_s_i_o_n.html#ab45f521464ad9e54d9b15efc2ffe20a1" title="Roll back the current transaction. ">WT_SESSION::rollback_transaction</a>. The <a class="el" href="struct_w_t___s_e_s_s_i_o_n.html#a96b8a369610c8cbb08b8a7c504fd1008" title="Prepare the current transaction. ">WT_SESSION::prepare_transaction</a> API only guarantees that transactional conflicts will not cause the transaction to rollback - it does not guarantee that the transactions updates are durable. If a read operation encounters an update from a prepared transaction a WT_PREPARE_CONFLICT error will be returned indicating that it is not possible to choose a version of data to return until a prepared transaction is resolved, it is reasonable to retry such operations.</p>
<p>Durability of the data updates performed by a prepared transaction, on tables configured with log=(enabled=false), can be controlled by specifying a durable timestamp during <a class="el" href="struct_w_t___s_e_s_s_i_o_n.html#a712226eca5ade5bd123026c624468fa2" title="Commit the current transaction. ">WT_SESSION::commit_transaction</a>. Checkpoint will consider the durable timestamp, instead of commit timestamp for persisting the data updates. If the durable timestamp is not specified, then the commit timestamp will be considered as the durable timestamp.</p>
<p>There are a number of constraints around assigning timestamps for running transactions - the table below summarizes those constraints:</p>
<table class="doxtable">
<tr>
<th>API </th><th>Prepared </th><th>Constraint </th><th>Enforced </th><th>Description  </th></tr>
<tr>
<td>Prepare </td><td>During </td><td>prepare_timestamp &gt;= stable_timestamp </td><td>Y </td><td>None </td></tr>
<tr>
<td>Commit </td><td>No </td><td>commit_timestamp &gt; stable_timestamp </td><td>Y </td><td>None </td></tr>
<tr>
<td>Commit </td><td>Yes </td><td>commit_timestamp &gt;= prepare_timestamp </td><td>Y </td><td>The commit timestamp may be older than the oldest timestamp at the time of commit. </td></tr>
<tr>
<td>Commit </td><td>Yes </td><td>durable_timestamp &gt; stable_timestamp </td><td>Y </td><td>None </td></tr>
<tr>
<td>Commit </td><td>Yes </td><td>durable_timestamp != 0 || commit_timestamp &gt; stable_timestamp </td><td>N </td><td>If no durable timestamp is given when committing a prepared transaction, the commit timestamp must be greater than the stable timestamp. </td></tr>
</table>
<h2><a class="anchor" id="timestamp_roundup"></a>
Automatic rounding of timestamps</h2>
<p>Applications setting timestamps for a transaction have to comply with the constraints based on the global timestamp state. In order to be compliant with the constraints applications need to query the global timestamp state and check their timestamps for compliance and adjust timestamps if required. To simplify the burden on applications related to rounding up timestamps WiredTiger supports automatic rounding of timestamps in some scenarios.</p>
<p>Applications can configure <code>roundup_timestamps=(prepared=true,read=true)</code> with <a class="el" href="struct_w_t___s_e_s_s_i_o_n.html#a7e26b16b26b5870498752322fad790bf" title="Start a transaction in this session. ">WT_SESSION::begin_transaction</a>.</p>
<p>The configuration <code>roundup_timestamps=(prepared=true)</code> will be valid only for prepared transactions. It indicates that the prepare timestamp could be rounded up to the oldest timestamp, if the prepare timestamp is less than the oldest timestamp. This setting also indicates that the commit timestamp of the transaction could be rounded up to the prepare timestamp, if the commit timestamp is less than the prepare timestamp. Based on the timestamps values and constraints, enabling this configuration could result in only one of timestamps being rounded up. For example, for the timestamp values <code>prepare_timestamp=100, commit_timestamp=300, oldest_timestamp=200</code> with configuration <code>roundup_timestamps=(prepared=true)</code> only the prepare timestamp will be rounded up to the oldest timestamp and the commit timestamp will not be adjusted and the result will be <code>prepare_timestamp=200, commit_timestamp=300, oldest_timestamp=200</code>. For cases where both the prepare timestamp and the commit timestamp needs to be rounded up, first the prepare timestamp will be rounded to the oldest timestamp and then the commit timestamp will be rounded up to the new prepare timestamp. For example, for the timestamp values <code>prepare_timestamp=100, commit_timestamp=150, oldest_timestamp=200</code> with configuration <code>roundup_timestamps=(prepared=true)</code>, the prepare timestamp is rounded up to the oldest timestamp, as part of the <a class="el" href="struct_w_t___s_e_s_s_i_o_n.html#a96b8a369610c8cbb08b8a7c504fd1008" title="Prepare the current transaction. ">WT_SESSION::prepare_transaction</a>, as <code>prepare_timestamp=200</code> and subsequently as part of <a class="el" href="struct_w_t___s_e_s_s_i_o_n.html#a712226eca5ade5bd123026c624468fa2" title="Commit the current transaction. ">WT_SESSION::commit_transaction</a>, the commit timestamp is rounded up to the new prepare timestamp as <code>commit_timestamp=200</code>.</p>
<p>Configuring <code>roundup_timestamps=(read=true)</code> causes the read timestamp to be rounded up to the oldest timestamp, if the read timestamp is greater than the oldest timestamp no change will be made.</p>
<h2><a class="anchor" id="timestamp_connection"></a>
Managing global timestamp state</h2>
<p>Applications that use timestamps need to manage some global state in order to allow WiredTiger to clean up old updates, and not make new updates durable until it is safe to do so. That state is managed using the <a class="el" href="struct_w_t___c_o_n_n_e_c_t_i_o_n.html#ad082439541b1b95d6aae6c15026fe512" title="Set a global transaction timestamp. ">WT_CONNECTION::set_timestamp</a> API.</p>
<p>Setting an oldest timestamp in <a class="el" href="struct_w_t___c_o_n_n_e_c_t_i_o_n.html#ad082439541b1b95d6aae6c15026fe512" title="Set a global transaction timestamp. ">WT_CONNECTION::set_timestamp</a> indicates that future read timestamps will be at least as recent as the oldest timestamp, so WiredTiger can discard history before the specified point. It is critical that the oldest timestamp update frequently or the cache can become full of updates, reducing performance.</p>
<p>Setting a stable timestamp in <a class="el" href="struct_w_t___c_o_n_n_e_c_t_i_o_n.html#ad082439541b1b95d6aae6c15026fe512" title="Set a global transaction timestamp. ">WT_CONNECTION::set_timestamp</a> indicates a known stable location that is sufficient for durability. During a checkpoint the state of a table will be saved only as of the stable timestamp. Newer updates after that stable timestamp will not be included in the checkpoint. That can be overridden in the call to <a class="el" href="struct_w_t___s_e_s_s_i_o_n.html#a6550c9079198955c5071583941c85bbf" title="Write a transactionally consistent snapshot of a database or set of objects. ">WT_SESSION::checkpoint</a>. It is expected that the stable timestamp is updated frequently. Setting a stable location provides the ability, if needed, to rollback to this location by placing a call to <a class="el" href="struct_w_t___c_o_n_n_e_c_t_i_o_n.html#a93dbc74accb426582b3c5c2f69e04b28" title="Rollback in-memory non-logged state to an earlier point in time. ">WT_CONNECTION::rollback_to_stable</a>. With the rollback, however, WiredTiger does not automatically reset the maximum commit timestamp it is tracking. The application should explicitly do so by setting a commit timestamp in <a class="el" href="struct_w_t___c_o_n_n_e_c_t_i_o_n.html#ad082439541b1b95d6aae6c15026fe512" title="Set a global transaction timestamp. ">WT_CONNECTION::set_timestamp</a>.</p>
<table class="doxtable">
<tr>
<th>Timestamp </th><th>Description </th><th>Constraint  </th></tr>
<tr>
<td>all_committed </td><td>The oldest timestamp at which all previous write transactions have committed. </td><td></td></tr>
<tr>
<td>last_checkpoint </td><td>The point at which the last checkpoint ran. If no checkpoint has run it's value will be 0. </td><td>last_checkpoint &lt;= stable timestamp </td></tr>
<tr>
<td>oldest </td><td>Point in time readers cannot be created using a timestamp older than the oldest timestamp, as explained above modification history is discarded prior to the oldest timestamp. This timestamp can be set via the API. </td><td>0 &lt;= oldest &lt;= stable </td></tr>
<tr>
<td>oldest_reader </td><td>The timestamp of the oldest currently active read transaction, if there is no current read transaction then querying for the oldest_reader with <a class="el" href="struct_w_t___c_o_n_n_e_c_t_i_o_n.html#a607cf2781661d03ba50586133e02cc11" title="Query the global transaction timestamp state. ">WT_CONNECTION::query_timestamp</a> will return WT_NOTFOUND. </td><td></td></tr>
<tr>
<td>pinned </td><td>Minimum of the oldest_reader and oldest timestamp. </td><td></td></tr>
<tr>
<td>recovery </td><td>The stable timestamp used, if any, in the most recent checkpoint prior to the last shutdown. </td><td></td></tr>
<tr>
<td>stable </td><td>Any active transaction with a commit timestamp less than or equal to the current stable timestamp will not be able to modify data, except in the instance of prepared transactions. This timestamp can be set via the API. </td><td>stable &gt;= oldest </td></tr>
</table>
<h2><a class="anchor" id="timestamp_extensions"></a>
Timestamp support in the extension API</h2>
<p>The extension API, used by modules that extend WiredTiger via <a class="el" href="struct_w_t___c_o_n_n_e_c_t_i_o_n.html#a99df5b3a17564eb5b3e4ec076590133d" title="Return a reference to the WiredTiger extension functions. ">WT_CONNECTION::get_extension_api</a>, is not timestamp-aware. In particular, <a class="el" href="struct_w_t___e_x_t_e_n_s_i_o_n___a_p_i.html#a618a7f943c768d687f1cab74f234b41f" title="Return the oldest transaction ID not yet visible to a running transaction. ">WT_EXTENSION_API::transaction_oldest</a> and <a class="el" href="struct_w_t___e_x_t_e_n_s_i_o_n___a_p_i.html#a213698d35a1cdd67e5d83ec998056707" title="Return if the current transaction can see the given transaction ID. ">WT_EXTENSION_API::transaction_visible</a> do not take timestamps into account. Extensions relying on these functions may not work correctly with timestamps. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">Reference Guide</a></li><li class="navelem"><a class="el" href="programming.html">Writing WiredTiger applications</a></li>
    <li class="footer">Copyright (c) 2008-2020 MongoDB, Inc.  All rights reserved.  Contact <a href="mailto:info@wiredtiger.com">info@wiredtiger.com</a> for more information.</li>
  </ul>
</div>
</body>
</html>
