.TH "cursor_log" 3 "Wed Apr 22 2015" "Version Version 2.5.3" "WiredTiger" \" -*- nroff -*-
.ad l
.nh
.SH NAME
cursor_log \- Log cursors 
WiredTiger cursors provide access to data from a variety of sources, and one of these sources is the records in the transaction log files\&. Log files may not be present in every WiredTiger database, only databases that have been configured for logging using the \fClog\fP configuration for \fBwiredtiger_open\fP\&. In databases with log files, a log cursor provides access to the log records\&. Although log cursors are read-only, applications may store records in the log using \fBWT_SESSION::log_printf\fP\&.
.PP
Each physical WiredTiger log record represents one or more operations in the database\&. When a log record represents more than a single operation in the database, all of the operations in a log record will be part of the same transaction, however, there is no corresponding guarantee that all operations in a transaction must appear in the same log record\&.
.PP
The following examples are taken from the complete example program \fBex_log\&.c\fP\&.
.PP
To open a log cursor on the database:
.PP
.PP
.nf
        ret = session->open_cursor(session, "log:", NULL, NULL, &cursor);
.fi
.PP
 A log cursor's key is a unique log record identifier, plus a uint32_t operation counter within that log record\&. When a log record maps one-to-one to a transaction (in other words, the returned log record has the only database operation the transaction made), the operation counter returned for the key will be zero\&.
.PP
The unique log record identifier maps to a \fBWT_LSN\fP data structure, which has two fields: WT_LSN::id, the log file identifier, and \fBWT_LSN::offset\fP, the offset of the log record in the log file\&.
.PP
Here is an example of getting the log cursor's key:
.PP
.PP
.nf
                ret = cursor->get_key(cursor, &lsn\&.file, &lsn\&.offset, &opcount);
.fi
.PP
 The log cursor's value is comprised of six fields:
.PP
.IP "\(bu" 2
a \fCuint64_t\fP transaction ID (set for commit records only, otherwise 0),
.IP "\(bu" 2
a \fCuint32_t\fP record type
.IP "\(bu" 2
a \fCuint32_t\fP operation type (set for commit records only, otherwise 0)
.IP "\(bu" 2
a \fCuint32_t\fP file id (if applicable, otherwise 0)
.IP "\(bu" 2
the operation key (commit records only, otherwise empty)
.IP "\(bu" 2
the operation value
.PP
.PP
The transaction ID may not be unique across recovery, that is, closing and reopening the database may result in transaction IDs smaller than previously seen transaction IDs\&.
.PP
The record and operation types are taken from \fBlog_types\fP; typically, the only record or operation type applications are concerned with is \fBWT_LOGREC_MESSAGE\fP, which is a log record generated by the application\&.
.PP
The file ID may not be unique across recovery, that is, closing and reopening the database may result in file IDs changing\&. Additionally, there is currently no way to map file IDs to file names or higher-level objects\&.
.PP
Here is an example of getting the log cursor's value:
.PP
.PP
.nf
                ret = cursor->get_value(cursor, &txnid,
                    &rectype, &optype, &fileid, &logrec_key, &logrec_value);
.fi
.PP
 For clarity, imagine a set of three log records:
.PP
.IP "\(bu" 2
the first with a single operation,
.IP "\(bu" 2
the second with five operations,
.IP "\(bu" 2
the third with a single operation\&.
.PP
.PP
The log cursor's \fBWT_CURSOR::next\fP call will return a total of seven records\&. The first time the log cursor will return a key with a unique log ID, a unique transaction ID, and an operation counter of 0\&. The next five returns from the log cursor will have a common log ID, a common transaction ID, and operation counters starting at 1 and ending at 5\&. The final return from the log cursor will again have a unique log ID, a unique transaction ID, and an operation counter of 0\&.
.PP
Here's a more complete example of walking the file file and displaying the results:
.PP
.PP
.nf
static void
print_record(WT_LSN *lsn, uint32_t opcount,
   uint32_t rectype, uint32_t optype, uint64_t txnid, uint32_t fileid,
   WT_ITEM *key, WT_ITEM *value)
{
        printf(
            "LSN [%" PRIu32 "][%" PRIu64 "]\&.%" PRIu32
            ": record type %" PRIu32 " optype %" PRIu32
            " txnid %" PRIu64 " fileid %" PRIu32,
            lsn->file, (uint64_t)lsn->offset, opcount,
            rectype, optype, txnid, fileid);
        printf(" key size %zu value size %zu\n", key->size, value->size);
        if (rectype == WT_LOGREC_MESSAGE)
                printf("Application Record: %s\n", (char *)value->data);
}

/*
 * simple_walk_log --
 *      A simple walk of the log\&.
 */
static int
simple_walk_log(WT_SESSION *session)
{
        WT_CURSOR *cursor;
        WT_LSN lsn;
        WT_ITEM logrec_key, logrec_value;
        uint64_t txnid;
        uint32_t fileid, opcount, optype, rectype;
        int ret;

        ret = session->open_cursor(session, "log:", NULL, NULL, &cursor);
        while ((ret = cursor->next(cursor)) == 0) {
                ret = cursor->get_key(cursor, &lsn\&.file, &lsn\&.offset, &opcount);
                ret = cursor->get_value(cursor, &txnid,
                    &rectype, &optype, &fileid, &logrec_key, &logrec_value);
                print_record(&lsn, opcount,
                    rectype, optype, txnid, fileid, &logrec_key, &logrec_value);
        }
        if (ret == WT_NOTFOUND)
                ret = 0;
        ret = cursor->close(cursor);
        return (ret);
}
.fi
.PP
 The log cursor's key can be used to search for specific records in the log (assuming the record still exists and has not been archived), by setting the key and calling \fBWT_CURSOR::search\fP\&. However, it is not possible to search for a specific operation within a log record, and the key's operation counter is ignored when the key is set\&. The result of a search for a log record with more than one operation is always the first operation in the log record\&.
.PP
Here is an example of setting the log cursor's key:
.PP
.PP
.nf
        cursor->set_key(cursor, lsnsave\&.file, lsnsave\&.offset, 0);
.fi
.PP
 Log cursors are read-only, however applications can insert their own log records using \fBWT_SESSION::log_printf\fP\&. Here is an example of adding an application record into the database log:
.PP
.PP
.nf
        ret = session->log_printf(session, "Wrote %d records", record_count);
.fi
.PP

