<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>WiredTiger: Operation Tracking</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="wiredtiger.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://wiredtiger.com/"><img alt="Logo" src="LogoFinal-header.png" alt="WiredTiger" /></a></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Version 10.0.0</span>
   </div>
   <div id="projectbrief"><!-- 10.0.0 --></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<div class="banner">
  <a href="https://github.com/wiredtiger/wiredtiger">Fork me on GitHub</a>
  <a class="last" href="http://groups.google.com/group/wiredtiger-users">Join my user group</a>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('devdoc-optrack.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Operation Tracking </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1>Overview</h1>
<p>Operation tracking tracks all API calls in WiredTiger as well as certain functions that are deemed important for performance, such as those in the eviction module. Tracking is performed by generating a log record when the execution enters and exits a tracked function. A log record contains a function name and its timestamp.</p>
<p>This tutorial will walk you through using operation tracking in WiredTiger on one of <code>wtperf</code> workloads: from preparing the workload for most effective data collection, to gathering, visualizing and interpreting the execution logs.</p>
<h2>Why use operation tracking?</h2>
<p>Analysis of WiredTiger JIRA tickets revealed that in diagnosing performance bugs engineers rely mostly on information that shows which functions were executed over time and across threads. They seek to find correlations between performance anomalies, such as long latencies or periods of low throughput, and events on these timelines. The purpose of operation tracking is to visualize the execution so that these correlations could be easily spotted.</p>
<h2>How does operation tracking work?</h2>
<p>Operation tracking allows you to put a pair of macros <code>WT_TRACK_OP_INIT</code> and <code>WT_TRACK_OP_END</code> into any function in WiredTiger whose invocation time you want to be measured and recorded. As your program runs, the <code>WT_TRACK_OP_INIT</code> macro will produce the function entry timestamp and <code>WT_TRACK_OP_END</code> macro will produce the function exit timestamp. These timestamps, along with the function name, will be recorded in a set of log files. It is typical to put the <code>WT_TRACK_OP_INIT</code> in the beginning of the function and the <code>WT_TRACK_OP_END</code> macro at every exit point from the function, but you can put them anywhere within the function body. The only condition required in order to correctly visualize the logs is that each <code>WT_TRACK_OP_INIT</code> has a matching <code>WT_TRACK_OP_END</code>. It is totally okay to insert tracking macros into nested functions.</p>
<h2>Will operation tracking introduce runtime overhead?</h2>
<p>The answer depends on your workload, and how many functions you track. For <code>wtperf</code> suite the largest overhead of 30% was observed on the CPU-bound workload <code>small-btree</code>. For I/O-bound workloads, such as <code>evict-btree-stress-multi</code>, the overhead is negligible, unless you decided to track short frequently executed functions.</p>
<h1>Prerequisites</h1>
<h2>Prepare your workload</h2>
<p>Modify your benchmark so that it produces the desired behavior with as little running time as possible. The longer the benchmark runs the more data it will produce, and the more difficult it will be for you to go over all this data.</p>
<p>In our running example with the <code>evict-btree-stress-multi.wtperf</code> workload, we separate the database creation phase from the work phase. We first create the database with operation tracking disabled. Then we enable operation tracking and run the work phase. So operation tracking logs are generated during the work phase only. We also reduce the work phase to 30 seconds, to make sure that the volume of information is manageable.</p>
<h2>Install the python modules</h2>
<p>To generate data visualizations, you will need the python modules bokeh, matplotlib and pandas installed. You can install them via the following commands (if you don't use pip modify for your python module manager): </p><pre class="fragment">pip install bokeh matplotlib pandas
</pre><h2>Enable operation tracking</h2>
<p>To enable operation tracking, you need to add the following option to your connection configuration string. </p><pre class="fragment">operation_tracking=(enabled=true,path=.)
</pre><p>For example, if you are running <code>wtperf</code>, you would add it to the <code>conn_config</code> string: </p><pre class="fragment">./wtperf -c conn_config="operation_tracking=(enabled=true,path=.)"
</pre><p>The "path" argument determines where the log files, produced by operation tracking, will be stored. Now you can run your workload.</p>
<h1>Working with log files</h1>
<h2>Becoming familiar with the operation tracking log files</h2>
<p>After the run is complete, the path directory will have a bunch of files of the following format: </p><pre class="fragment">optrack.00000&lt;pid&gt;.000000000&lt;sid&gt;
</pre><p>and the file </p><pre class="fragment">optrack-map.00000&lt;pid&gt;
</pre><p>where <code>pid</code> is the process ID and <code>sid</code> is the session ID.</p>
<p>The first kind of files are the actual log files. The second is the map file. Log files are generated in the binary format, because this is a lot more efficient than writing strings, and the map file is needed to decode them.</p>
<h2>Processing the log files</h2>
<p>Now the binary log files need to be converted into the text format. To do that use the script <code>wt_optrack_decode.py</code> in the WiredTiger tree. We will refer to the path to your WiredTiger tree as WT. Suppose that the process ID that generated the operation tracking files is 25660. Then you'd run the decode script like so: </p><pre class="fragment">% python WT/tools/optrack/wt_optrack_decode.py -m optrack-map.0000025660 optrack.0000025660.00000000*
</pre><p>As the script runs you will see lots of output on the screen reporting the progress through the parsing process. One kind of output you might see is something like this: </p><pre class="fragment">TSC_NSEC ratio parsed: 2.8000
</pre><p>This refers to the clock cycles to nanoseconds ratio encoded into the log files. In the example above, we had 2.8 ticks per nanosecond, suggesting that the workload was run on a 2.8 GHz processor. This ratio is used later to convert the timestamps, which are recorded in clock cycles for efficiency, to nanoseconds.</p>
<p>In the end, you should see lots of output files whose names look like the optrack log files, but with the suffixes <code>-internal.txt</code> and <code>-external.txt</code>. The "internal" files are the log files for WT internal sessions (such as eviction threads). The "external" files are for the sessions created by the client application.</p>
<h2>Preparing data for viewing</h2>
<p>There are two ways to view operation tracking data, besides manually plowing through the log files. The quickest way is to generate CSV files viewable with <code>t2</code> &ndash; MongoDB's internal tool. With <code>t2</code>, you can view the frequency of tracked operations across time and across threads, like this:</p>
<div class="image">
<img src="optrack-t2-slow-lsm-worker-thread.png" alt="optrack-t2-slow-lsm-worker-thread.png"/>
<div class="caption">
Perf output visualized with t2</div></div>
<p> To produce a CSV file that can be loaded directly into <code>t2</code>, run the following command: </p><pre class="fragment">% WT/tools/optrack/optrack_to_t2.py optrack.0000025660.00000000*.txt
</pre><p>The second option is to use a script that will help you locate latency spikes &ndash; invocations of operations that took an unusually long time &ndash; and visually examine per-thread operation logs around those spikes. To obtain such a visualization, use the script <code>find-latency-spikes.py</code> located in the <code>tools/optrack</code> directory of the WiredTiger tree. To process the text files in our example, you run this script as follows: </p><pre class="fragment">% WT/tools/optrack/find-latency-spikes.py optrack.0000025660.00000000*.txt
</pre><p>As the script runs, you will probably see messages similar to this one: </p><pre class="fragment">Processing file optrack.0000025660.0000000026-external.txt
Your data may have errors. Check the file .optrack.0000025660.0000000026-external.txt.log for details.
</pre><p>This means that as the script was processing the log file, it found some inconsistencies, for example there was a function entry timestamp, but no corresponding function exit, or vice versa. Sometimes these errors are benign. For example, the log file will never have an exit timestamp from a session-closing function, because operation tracking is torn down as the session closes. In other cases, an error may indicate that there is a mistake in how the operation-tracking macros were inserted. For example, the programmer may have forgotten to insert a macro where there is an early return from a function. Examining the log file mentioned in the error message will give you more details on the error.</p>
<p>The data processing script will not fail or exit if it encounters these error messages, it will proceed despite them, attempting to visualize the portion of the log that did not contain the errors. The function timestamps implicated in the errors will simply be dropped.</p>
<p>At the very end of the processing, you will see messages like this: </p><pre class="fragment">Normalizing data...
Generating timeline charts... 99% complete
Generating outlier histograms... 100% complete
</pre><p>This is how you know the processing has completed. The script takes a while to run, but it is parallelizable, so that is something that can be done in the future to speed it up.</p>
<h1>Looking at the data: Part 1</h1>
<p>In the directory where you ran the data processing script, you will have the file <code>WT-outliers.html</code> and the directory <code>BUCKET-FILES</code> to which that HTML file refers. If you would like to look at the visualization on another machine, transfer both the HTML file and the directory to that machine. Otherwise, just open <code>WT-outliers.html</code> locally in your browser.</p>
<p>To get an idea of what kind of output you will see, take a look at <a href="http://www.ece.ubc.ca/~sasha/TUTORIAL-DEMO/">this example data</a> generated by the workload described earlier in this tutorial. Please open the URL, because we will now walk over what it shows.</p>
<p>The main page shows a number of outlier histograms. Each histogram corresponds to a function that was tracked by the operation tracking system in WT. The x-axis shows the execution timeline (in nanoseconds). The y-axis shows how many abnormally long executions of the function occurred during very period of the execution.</p>
<div class="image">
<img src="outlier_histograms.png" alt="outlier_histograms.png"/>
</div>
<p>You can click on outlier bars and look at the detailed visualization of the period during which the abnormally long function invocations occurred. But before we do that, let's talk about what is considered an "outlier" or an "abnormally long execution" and how to control these thresholds. As annotations on the histograms show, by default a function invocation is considered an outlier if its duration is longer than two standard deviations above average. (The average is computed for this function over the entire execution). If you would like a more precise control of outlier thresholds, you can do that in a configuration file that is read by the execution script.</p>
<p>Before we talk about other visualization screens, let's actually generate a visualization with some more meaningful outlier thresholds than two standard deviations. This way, it will be easier to navigate the data, and we will be able to observe some very interesting behavior that gives us a clue as to why eviction is sometimes slow. (If you can't wait to find out, skip over the next step.)</p>
<h2>Getting a more precise control of the outlier thresholds</h2>
<p>Let's learn how to configure custom outlier thresholds. The easiest way to begin is to grab a sample configuration file and edit it to your needs: </p><pre class="fragment">% cp WT/tools/optrack/sample.config .
</pre><p>Here is how that file looks: </p><pre class="fragment"># Units in which timestamps are recorded
1000000000
# Outlier threshold for individual functions
__curfile_reset 100 ms
__curfile_search 50 ms
__curfile_update 3 ms
__evict_lru_pages 75 ms
__evict_lru_walk 20 ms
__evict_page 75 ms
__evict_walk 20 ms
__wt_cache_eviction_worker 10 ms
__wt_cond_wait_signal 5 s
__wt_cursor_set_valuev 10 ms
</pre><p>In that file all lines prefixed with a # are comments.</p>
<p>The first non-comment line specifies the units in which your timestamps are recorded. The units are specified by providing a value indicating how many time units there are in a second. By default operation scripts generate timestamps in nanoseconds, hence you see a value of 1000000000 on the first line in our sample file. If your time units were, say, milliseconds, you'd change that value to 1000, and so on.</p>
<p>The remaining non-comment lines in the file provide the outlier thresholds for any functions you care to have a custom threshold. The format is: </p><pre class="fragment">&lt;function name&gt; &lt;value&gt; &lt;unit&gt;
</pre><p>For example, to specify a threshold of 15 milliseconds for the <code>__wt_cache_eviction_worker</code> function, you'd insert the following line: </p><pre class="fragment">__wt_cache_eviction_worker 15 ms
</pre><p>Valid units are nanoseconds (ns), microseconds (us), milliseconds (ms) and seconds (s).</p>
<p>If you don't specify a threshold for a function the default of two standard deviations will be used. Let's actually configure some more meaningful outlier thresholds in our <code>sample.config</code> file and re-run the visualization script. Here is the modified <code>sample.config</code>: </p><pre class="fragment"># Units in which timestamps are recorded
1000000000
# Outlier threshold for individual functions
__curfile_search 30 ms
__evict_lru_pages 250 ms
__evict_lru_walk 1 ms
__evict_page 15 ms
__evict_walk 1 ms
__wt_cache_eviction_worker 15 ms
__wt_cond_wait_signal 10 s
</pre><p>We rerun the data processing script with the configuration file argument, like so: </p><pre class="fragment">% WT/tools/optrack/find-latency-spikes.py -c sample.config optrack.0000025660.00000000*.txt
</pre><p>The new charts can be accessed <a href="http://www.ece.ubc.ca/~sasha/TUTORIAL-DEMO-CONFIG/">here</a>.</p>
<h1>Looking at the data: Part 2</h1>
<p>Let's examine the visualized data in more detail. Please click on <a href="http://www.ece.ubc.ca/~sasha/TUTORIAL-DEMO-CONFIG/">this URL</a>:</p>
<p>Although I insert the screenshots here, you will have more fun if you access it directly.</p>
<p>Now you can see the outlier charts complying with the configuration parameters we supplied. For example, on the chart for the <code>__wt_cache_eviction_worker</code>, we see only the intervals where that function took longer than 15 ms to complete.</p>
<div class="image">
<img src="wt_cache_eviction_worker_outliers.png" alt="wt_cache_eviction_worker_outliers.png"/>
</div>
<p>Let's click on one of those intervals to examine what happened there. I am going to click on the tallest bar in the chart, which will take me to a detailed output of function call activity by thread for interval 137 at <a href="http://www.ece.ubc.ca/~sasha/TUTORIAL-DEMO-CONFIG/BUCKET-FILES/bucket-137.html">this URL</a>.</p>
<p>There is a lot of graphics there, so the URL might take a few seconds to load.</p>
<p>At the very top of the page you see a small navigation bar. The bar tells you where you are in the execution (the red marker). By clicking on other intervals within the bar you can navigate to other intervals. For example, if you wanted to look at the execution interval located after the current one, you will just click on the white bar following the current, red-highlighted, bar.</p>
<div class="image">
<img src="interval_137_nav_bar.png" alt="interval_137_nav_bar.png"/>
</div>
<p>Next you see a legend that shows all functions that were called during this execution interval and their corresponding colours.</p>
<div class="image">
<img src="interval_137_lgnd.png" alt="interval_137_lgnd.png"/>
</div>
<p>Then you will see the most interesting information: function calls across threads that occurred during this period. Durations and hierarchy of function calls is preserved, meaning that longer functions will be shown with longer bars and if function A called function B, B will be shown on top of A.</p>
<p>By hovering over the colored bars corresponding to functions, you will see a box appear telling you the name of the function, how long it took and its original timestamp in your operation tracking log file. This way, if you are suspicious about the correctness of your log or want to go back to it for some reason, you know what to look for.</p>
<p>In our example visualization, if we scroll down to the function sequences for external threads, we will quickly see a few instances where __wt_cache_eviction_worker took longer than 15 ms, for example here:</p>
<div class="image">
<img src="wt_cache_eviction_worker_over_15ms.png" alt="wt_cache_eviction_worker_over_15ms.png"/>
</div>
<p>As we can see, the threads are simply waiting on the condition variable inside the eviction worker. To try and understand why, we might want to scroll up and look at the activity of internal threads during this period. Interestingly enough, most of the internal threads are also waiting on the condition variable during this period.</p>
<div class="image">
<img src="interval_137_threads_waiting.png" alt="interval_137_threads_waiting.png"/>
</div>
<p>Looking at the internal thread with session id 1 shows something suspicious.</p>
<div class="image">
<img src="session_1_dead_period.png" alt="session_1_dead_period.png"/>
</div>
<p>During this period where all threads are waiting, this thread shows no activity at all, whereas prior and after that "dead" period it was making regular calls to <code>__evict_walk</code>. Perhaps that thread was unscheduled or stopped calling __evict_walk for other reasons. Perhaps other threads were dependent on work performed within <code>__evict_walk</code> to make forward progress.</p>
<p>To better understand why <code>__evict_walk</code> was interrupted for almost 10ms we might want to go back and insert operation tracking macros inside the functions called by <code>__evict_walk</code>, to see if the thread was doing some other work during this time or was simply unscheduled.</p>
<h1>Summary</h1>
<p>Operation tracking is great for debugging performance problems where you are interested in understanding the activity of the workload over time and across threads. To effectively navigate large quantities of data it is best to reproduce your performance problem in a short run. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">Reference Guide</a></li><li class="navelem"><a class="el" href="devdoc-index.html">Developer Documentation</a></li>
    <li class="footer">Copyright (c) 2008-2020 MongoDB, Inc.  All rights reserved.  Contact <a href="mailto:info@wiredtiger.com">info@wiredtiger.com</a> for more information.</li>
  </ul>
</div>
</body>
</html>
