<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>WiredTiger: Cursor</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="sorttable.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="wiredtiger.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://wiredtiger.com/"><img alt="Logo" src="LogoFinal-header.png" alt="WiredTiger" /></a></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Version 11.2.0</span>
   </div>
   <div id="projectbrief"><!-- 11.2.0 --></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<div class="banner">
  <a href="https://github.com/wiredtiger/wiredtiger">Fork me on GitHub</a>
  <a class="last" href="http://groups.google.com/group/wiredtiger-users">Join my user group</a>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('arch-cursor.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Cursor </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><div class="arch_head"><table class="doxtable">
<tr>
<th rowspan="2" style="width:10%;"> <div><a href="arch-index.html"><img class="arch_thumbnail" src="wt_diagram.png" usemap="#wt_diagram_map" style="background-image: url(wt_diagram.png)"></a></div></th><th style="width:44%">Data Structures</th><th style="width:45%">Source Location</th></tr>
<map id="wt_diagram_map" name="wt_diagram_map">
<area shape="rect" id="id1" href="modules.html" title="modules.html" alt="" coords="248,128,283,144"/>
<area shape="rect" id="id2" href="arch-cache.html" title="arch-cache.html" alt="" coords="204,546,248,562"/>
<area shape="rect" id="id3" href="arch-cursor.html" title="arch-cursor.html" alt="" coords="234,224,280,240"/>
<area shape="rect" id="id4" href="arch-eviction.html" title="arch-eviction.html" alt="" coords="303,546,356,562"/>
<area shape="rect" id="id5" href="arch-logging.html" title="arch-logging.html" alt="" coords="388,650,443,666"/>
<area shape="rect" id="id6" href="arch-schema.html" title="arch-schema.html" alt="" coords="123,224,179,240"/>
<area shape="rect" id="id7" href="command_line.html" title="command_line.html" alt="" coords="374,23,430,39"/>
<area shape="rect" id="id8" href="arch-log-file.html" title="arch-log-file.html" alt="" coords="308,865,339,897"/>
<area shape="rect" id="id9" href="arch-metadata.html" title="arch-metadata.html" alt="" coords="25,328,89,344"/>
<area shape="rect" id="id10" href="arch-python.html" title="arch-python.html" alt="" coords="84,23,157,39"/>
<area shape="rect" id="id11" href="arch-snapshot.html" title="arch-snapshot.html" alt="" coords="297,441,371,457"/>
<area shape="rect" id="id12" href="arch-transaction.html" title="arch-transaction.html" alt="" coords="298,328,387,344"/>
<area shape="rect" id="id13" href="arch-hs.html" title="arch-hs.html" alt="" coords="93,642,140,674"/>
<area shape="rect" id="id14" href="arch-block.html" title="arch-block.html" alt="" coords="196,642,256,674"/>
<area shape="rect" id="id15" href="arch-dhandle.html" title="arch-dhandle.html" alt="" coords="144,320,205,352"/>
<area shape="rect" id="id16" href="arch-data-file.html" title="arch-data-file.html" alt="" coords="179,865,245,897"/>
<area shape="rect" id="id17" href="arch-row-column.html" title="arch-row-column.html" alt="" coords="117,433,205,465"/>
<area shape="rect" id="id18" href="arch-fs-os.html" title="arch-fs-os.html" alt="" coords="175,755,357,771"/>
</map>
<tr>
<td><code><code><a class="el" href="struct_w_t___c_u_r_s_o_r.html" title="A WT_CURSOR handle is the interface to a cursor.">WT_CURSOR</a><br  />
WT_CURSOR_BACKUP<br  />
WT_CURSOR_BTREE<br  />
WT_CURSOR_BULK<br  />
WT_CURSOR_DATA_SOURCE<br  />
WT_CURSOR_DUMP<br  />
WT_CURSOR_INDEX<br  />
WT_CURSOR_LOG<br  />
WT_CURSOR_METADATA<br  />
WT_CURSOR_STAT</code></code></td><td><code><code>src/include/cursor.h<br  />
src/include/cursor_inline.h<br  />
src/cursor/</code></code></td></tr>
</table>
</div><p> <b>Caution: the Architecture Guide is not updated in lockstep with the code base and is not necessarily correct or complete for any specific release.</b></p>
<p>Cursors are used in WiredTiger to get and modify data. A caller of WiredTiger uses <a class="el" href="struct_w_t___s_e_s_s_i_o_n.html#afb5b4a69c2c5cafe411b2b04fdc1c75d" title="Open a new cursor on a data source or duplicate an existing cursor.">WT_SESSION::open_cursor</a> to create a <a class="el" href="struct_w_t___c_u_r_s_o_r.html" title="A WT_CURSOR handle is the interface to a cursor.">WT_CURSOR</a>. Methods on the <a class="el" href="struct_w_t___c_u_r_s_o_r.html" title="A WT_CURSOR handle is the interface to a cursor.">WT_CURSOR</a> can then be used to position, iterate, get, and set data. In the typical case, a cursor will be used to access keys and values in a Btree. However, cursors can also used to access indexed data, WiredTiger statistics, log files, and metadata. Additionally, cursors are used for managing backups.</p>
<p>The various kinds of cursors are created by the <a class="el" href="struct_w_t___s_e_s_s_i_o_n.html#afb5b4a69c2c5cafe411b2b04fdc1c75d" title="Open a new cursor on a data source or duplicate an existing cursor.">WT_SESSION::open_cursor</a> call. Depending on the <code>uri</code> used when opening a cursor, the cursor will be implemented internally as one of the many cursor structures that include <code>WT_CURSOR_BTREE</code>, <code>WT_CURSOR_BACKUP</code>, <code>WT_CURSOR_INDEX</code>, <code>WT_CURSOR_LOG</code>, <code>WT_CURSOR_METADATA</code>, <code>WT_CURSOR_STAT</code>, <code>WT_CURSOR_TABLE</code>. Each of these structures starts with the common <code>WT_CURSOR</code> structure, which contain all of the data and method pointers that make up the public part of the API. Thus, any one of these "extended cursor structs" can be allocated and returned as a <a class="el" href="struct_w_t___c_u_r_s_o_r.html" title="A WT_CURSOR handle is the interface to a cursor.">WT_CURSOR</a> pointer. Since the method pointers are filled with a specific implementations, for example <code>__curtable_reset</code>, a call to <a class="el" href="struct_w_t___c_u_r_s_o_r.html#afc1b42c22c9c85e1ba08ce3b34437565" title="Reset the cursor.">WT_CURSOR::reset</a> will call the specific implementation function, and the first argument can be cast to be a pointer to the cursor struct used by the implementation. Thus, in our C code, we have something similar to a class hierarchy, having an abstract base class (<a class="el" href="struct_w_t___c_u_r_s_o_r.html" title="A WT_CURSOR handle is the interface to a cursor.">WT_CURSOR</a>) with virtual methods, and a number of implementation classes.</p>
<p>The code for each cursor type's methods are generally organized in a single file. For example, a backup cursor is implemented in <code>src/cursor/cur_backup.c</code> . Similarly, shared or utility cursor methods are defined in <code>src/cursor/cur_std.c</code> .</p>
<p>Several cursor types have the concept of subordinate cursors, or child cursors. For example, a table cursor is composed of subordinate file cursors, each representing a column group. A metadata cursor has a subordinate cursor that is a file cursor on the metadata file.</p>
<p>Every open cursor appears on a list in <code>WT_SESSION-&gt;cursors</code>. This list is ordered in a way that cursors are closed when the session is closed. Thus, if a subordinate cursor needs to be closed before its parent, it must be listed before the parent.</p>
<h1><a class="anchor" id="arch_cursor_raw"></a>
Data translation</h1>
<p>Cursors that expose Btree data, like file, table and index cursors, return a set of keys and values, translating encoded data to types that match the schema. For example, if the <code>value_format</code> specified for a table is <code>"iSi"</code> (an integer, a null-terminated string, an integer), then data <code>{0, "abc", 5}</code> might be stored in the Btree in a packed format as: </p><div class="fragment"><div class="line">0x80 0x61 0x62 0x63 0x00 0x85</div>
</div><!-- fragment --><p>When retrieved, the values are decoded and stored into typed variables whose addresses are passed to <a class="el" href="struct_w_t___c_u_r_s_o_r.html#af85364a5af50b95bbc46c82e72f75c01" title="Get the value for the current record.">WT_CURSOR::get_value</a>.</p>
<p>As an aside, <code>0x80</code> represents <code>0</code> using a variable length encoding. Using 0x80 as zero allows negative integers to be stored (<code>-1</code> is <code>0x7f</code>) in a way that they will sort before zero and positive integers. Small integer values can be stored in a single byte. See comments in <code>src/include/intpack_inline.h</code> for more information.</p>
<p>When creating a cursor via <a class="el" href="struct_w_t___s_e_s_s_i_o_n.html#afb5b4a69c2c5cafe411b2b04fdc1c75d" title="Open a new cursor on a data source or duplicate an existing cursor.">WT_SESSION::open_cursor</a>, the <em>raw</em> flag can be used. This has the effect of disabling the translation provided by the schema, transferring a single block of unencoded data for the key or value.</p>
<h1><a class="anchor" id="arch_cursor_file"></a>
File cursors</h1>
<p>File cursors (also known as Btree cursors) are one of fundamental kind of cursors, allowing direct accesses to WiredTiger Btrees. The implementation structure for a file cursor is <code>WT_CURSOR_BTREE</code>. The file cursor methods are generally small wrappers around calls into the Btree layer, where the <code>WT_CURSOR_BTREE</code> structure is used. The Btree layer handles all aspects of cursor positioning, and transfers of raw key and value data.</p>
<h1><a class="anchor" id="arch_cursor_table"></a>
Table and index cursors</h1>
<p>A table cursor is a higher level concept built on file cursors. A WiredTiger table allows data to be physically split into separate Btrees, this is done via the concept of column groups. Column groups may be defined that contain a set of named columns (<code>columns</code> are synonymous with <code>fields</code>). Each column group's columns are the stored in a single btree and may be looked up by the table's key. See <a class="el" href="schema.html#schema_column_groups">Column groups</a> for API details.</p>
<p>Tables may also have indices. These are implemented as Btrees mapping the index key(s) to the main key(s) of the table. Indices may be added after the data is populated in the main table. This requires the index to be filled at the time it is added. Index cursors are implemented using <code>WT_CURSOR_INDEX</code>. Methods on this cursor that set and get values know to use the value that appears in the index as a key into the main table. See <a class="el" href="schema.html#schema_indices">Indices</a> for API details.</p>
<p>Internally, we define the concept of a "simple" table as one that has no named columns. <em>Columns</em>, that is the set of keys and values, may be optionally named when creating a table. With no named columns, column groups are not possible (as they must reference names), and all of a table's keys and values reside in a single file. Also without named columns, there is no possibility that a cursor can use projections. A "simple" table, by its nature, can be implemented by a single Btree file and needs no special translation. Thus, if a cursor is opened on a "simple" table, we can return a file cursor on the single file used to store its data, instead of a table cursor. This optimization means that every cursor method goes directly to the file cursor implementation, saving CPU time throughout the lifetime of the cursor.</p>
<h1><a class="anchor" id="arch_cursor_projections"></a>
Projections and plans</h1>
<p>Projections are an indication, when a cursor is opened, that the indicated values, and possibly some keys, should be returned by <a class="el" href="struct_w_t___c_u_r_s_o_r.html#af85364a5af50b95bbc46c82e72f75c01" title="Get the value for the current record.">WT_CURSOR::get_value</a> calls. This is only available for table cursors. If the table was configured with column groups, a projection has a bearing on which column group files must be opened in a cursor. When a subset of values is returned, it's possible that some column groups will not be needed. To implement projections and column groups, cursors use a <em>plan</em>.</p>
<p>A plan is a string that indicates a series of actions that must be taken to retrieve the needed values from the subordinate cursors in the table cursor. Remember that each column group gets its own cursor. When a table is created, a default plan is created that asks to copy all columns from each column group cursor in order. When a projection is used for a cursor, a more complex plan may be created. A plan contains numbers and action letters. The numbers are arguments, the action letters are commands. The actions 'k' and 'v' indicate that the subordinate cursor indicated by the numeric argument will be used to get keys or values that follow. The 'n' action gets one or more next key or value columns from the cursor. The 's' skips one or more columns. Switching to another cursor resets the cursor to point at the first column in the indicated cursor. This allows a way to find keys and values in arbitrary order.</p>
<p>As a contrived example, suppose we have a table with two keys <code>"k1,k2"</code> and four values <code>"x1,x2,x3,x4"</code>. The column groups are created as follows: </p><div class="fragment"><div class="line">session-&gt;<a class="code" href="struct_w_t___s_e_s_s_i_o_n.html#a358ca4141d59c345f401c58501276bbb">create</a>(session, <span class="stringliteral">&quot;colgroup:main:c1&quot;</span>, <span class="stringliteral">&quot;columns=(x1,x2)&quot;</span>);</div>
<div class="line">session-&gt;<a class="code" href="struct_w_t___s_e_s_s_i_o_n.html#a358ca4141d59c345f401c58501276bbb">create</a>(session, <span class="stringliteral">&quot;colgroup:main:c2&quot;</span>, <span class="stringliteral">&quot;columns=(x3,x4)&quot;</span>);</div>
</div><!-- fragment --><p>The column group <code>"main:c1"</code> has keys "k1,k2" and values "x1,x2"; the column group <code>"main:c2"</code> has keys "k1,k2" and values "x3,x4". A table cursor on the main table will have two sub-cursors, one for each column group. Now consider the ill-considered projection that is opened as: </p><div class="fragment"><div class="line">session-&gt;<a class="code" href="struct_w_t___s_e_s_s_i_o_n.html#afb5b4a69c2c5cafe411b2b04fdc1c75d">open_cursor</a>(session, <span class="stringliteral">&quot;table:main(x1,x4,x3,k2,k1,x2,x4)&quot;</span>, NULL, NULL, &amp;cursor);</div>
</div><!-- fragment --><p>In this case, the plan is this string (with spacing added): </p><div class="fragment"><div class="line">0v n 1v s n 1v n 0k s n 0k n 0v s n 1v s n</div>
</div><!-- fragment --><p>To break it down,</p><ul>
<li><code>"0v"</code> means use sub-cursor 0 and prepare to read values.</li>
<li><code>"n"</code> means get the next value, that is <code>"x1"</code>.</li>
<li><code>"1v"</code> means use sub-cursor 1 and prepare to read values.</li>
<li><code>"s"</code> means skip a value, that is <code>"x3"</code>.</li>
<li><code>"n"</code> means get the next value, that is <code>"x4"</code>.</li>
<li><code></code>...</li>
</ul>
<p>Notice that this plan requires many switches of cursors and several <code>"s"</code> (skip) operations. Each skip involves enough decoding of the data item to determine its length so its data can be skipped over.</p>
<p>With the default (complete) projection, getting values is fast. Using the default plan, the needed columns are pulled out of each subordinate cursor one by one, and get copied to the caller's arguments. With projections, the simple algorithm following the plan works well if the columns in the projection are grouped by column group and requested in order. Without that discipline, as in this example, the performance will not be optimal.</p>
<p>The implementation of plan creation and execution resides in the <a class="el" href="arch-schema.html">Schema</a>.</p>
<h1><a class="anchor" id="arch_cursor_dump"></a>
Dump cursors</h1>
<p>Dump cursors are used in two rather different ways. Regular dump cursors retrieve the raw keys and values and translate bytes either as raw characters or as hex values. This flavor of dump cursor is used by the <code>wt dump</code> or <code>wt dump -x</code> utility. JSON dump cursors do more sophisticated translation, returning a string that is a JSON formatted record, with the name for each key and its data and the name for each value and its corresponding data. Data is translated to either integral, floating point, or string depending on the format of the column in the schema. This flavor of dump cursor is used by the <code>wt dump -j</code> command as part of creating a JSON dump of a WiredTiger table or file.</p>
<p>There is a single <code>WT_CURSOR_DUMP</code> struct that is used to implement both flavors. The dump code checks for the <code>WT_CURSTD_DUMP_JSON</code> flag and as needed, calls into functions in <code>src/cursor/cur_json.c</code> . The code in that file also implements several external functions that are used by the <code>wt</code> utility when loading JSON-dumped files. In particular, the <code>__wt_json_token</code> function returns individual JSON tokens from an input string.</p>
<p>The JSON code used by the dump cursor uses some storage that hangs off of <code>cursor-&gt;json_private</code> which is typed as <code>WT_CURSOR_JSON</code>. When a JSON flavored cursor is created, the list of key column names and value column names is populated in <code>WT_CURSOR_JSON</code>. These names, obtained from the configuration string that created the table or file, are useful to have in advance, as they are used once per row to help fill out the JSON output. The functions that get rows iterate these names and unpack the corresponding column data, converting them into the appropriate JSON format for the data.</p>
<h1><a class="anchor" id="arch_cursor_backup"></a>
Backup cursors</h1>
<p>A backup cursor is used to manage backups. It is implemented using a <code>WT_CURSOR_BACKUP</code> structure. A backup cursor can be configured to do a full backup or an incremental backup. First, we'll look at full backups.</p>
<p>A backup cursor for a full backup returns the set of files that need to be copied to achieve the backup. The backup cursor, when opened, ensures that it is the only backup cursor running in the system and returns an error if not. This is managed using the <code>WT_CONNECTION_IMPL-&gt;hot_backup_start</code> variable, which can only be accessed when the connection schema lock is held. A non-zero value means a hot backup is in progress. Closing the backup cursor sets it back to zero.</p>
<p>Having an open backup influences actions elsewhere in WiredTiger, since part of the backup protocol involves the application copying whole data files. Thus, having an open backup may cause the block manager and log file server thread to avoid truncating data and log files. A truncation of a file being copied by the application would be unexpected. Also, open checkpoints are not deleted during the course of a backup.</p>
<p>When the backup cursor is initialized, the complete set of files needed to back up is generated and stored in the cursor. This makes the backup's <code>next</code> function easy as it just returns the next file in the list.</p>
<p>Incremental backups work much the same way, except that the file list is reduced to files that have changed since a previous backup referenced in the configuration when the cursor is opened. The other twist is that for each file returned, the caller does a duplicate operation on the backup cursor, and the duplicate code actually returns a specialized incremental backup cursor. This kind of cursor has its own <code>next</code> method that causes it to return information about individual pieces of this file that need to be copied. The code to implement incremental cursors is in <code>src/cursor/cur_backup_incr.c</code> .</p>
<h1><a class="anchor" id="arch_cursor_join"></a>
Join cursors</h1>
<p>Join cursors implement a join mechanism for WiredTiger. The idea is that joins can be configured by opening a special join cursor on a table, and attaching the table's index cursors to it, to return rows that match a filter, like: </p><div class="fragment"><div class="line">(row.price &gt; 100 and row.price &lt;= 200) and row.in_stock &lt; 10</div>
</div><!-- fragment --><p>Building up the conditions essentially creates a tree that is used for evaluation. This is stored in <code>WT_CURSOR_JOIN</code>, and is returned as the cursor object. Entries in the tree representing an index's participation in one clause are stored in <code>WT_CURSOR_JOIN_ENTRY</code> objects. <code>WT_CURSOR_JOIN</code> and <code>WT_CURSOR_JOIN_ENTRY</code> objects can be composed in a hierarchical manner, representing the shape of the tree representing the query. These two structures are somewhat static, being created when the join is created.</p>
<p>The join cursor contains a pointer to a <code>WT_CURSOR_JOIN_ITER</code>, which in some sense encodes the "position" of the cursor. To get the next row that satisfies a join requires that multiple cursors be iterated. Generally, the "left-most" index cursor is iterated first. Using the example above, the <code>price</code> index would be iterated, skipping over any entries that did not satisfy <code>(row.price &gt; 100 and row.price &lt;= 200)</code>. Then other cursors are checked to see that any other conditions are satisfied. The join may be configured to use Bloom filters, and when that occurs, <code>WT_CURSOR_JOIN_ENTRIES</code> contain the bloom filter for individual index checks. This allows checks to occur quickly, at the expense of an initialization that occurs when the cursor begins iteration.</p>
<p>During a join cursor iteration, multiple <code>WT_CURSOR_JOIN_ITER</code> objects may be created. There is one <code>WT_CURSOR_JOIN_ITER</code> object corresponding to each level of nesting (queries can have arbitrary nesting of <code>AND/OR</code>). Each <code>WT_CURSOR_JOIN_ITER</code> allows the question to be asked: does the current position of the main table cursor satisfy the join conditions for this part of the join tree?</p>
<p>Part of the reason for this dynamic structure is that disjunctions may require some dynamic action. Consider </p><div class="fragment"><div class="line">(row.price &gt; 100 and row.in_stock &lt; 10) .... or (row.aisle == 12 and row.on_sale == 1)</div>
</div><!-- fragment --><p>The last part of the query (being part of an OR clause) will be first executed after a number of items are returned that satisfy the first part of the query. If the join cursor is closed before then, it would be a waste to have opened subordinate cursors on the <code>aisle</code> and <code>on_sale</code> indices, and potentially computed bloom filters, etc.</p>
<p>When positioned on an entry that represents a nested join, a new child <code>WT_CURSOR_JOIN_ITER</code> is created that will be bound to the nested <code>WT_CURSOR_JOIN</code>. That iterator is then used to generate candidate primary keys. When its iteration is completed, that iterator is destroyed and the parent iterator advances to the next entry. Thus, depending on how deeply joins are nested, a similarly deep stack of iterators is created.</p>
<h1><a class="anchor" id="arch_cursor_duplicate"></a>
Duplicating cursors</h1>
<p>Cursors may be duplicated, this occurs by passing a cursor to be duplicated as part of the <a class="el" href="struct_w_t___s_e_s_s_i_o_n.html#afb5b4a69c2c5cafe411b2b04fdc1c75d" title="Open a new cursor on a data source or duplicate an existing cursor.">WT_SESSION::open_cursor</a> call. Cursor duplication does not occur in the cursor type code. Rather, a new cursor of the requested type is created, and the cursor's position is duplicated via a call to <code>__wt_cursor_dup_position</code>. This function gets the key from the original cursor in <em>raw</em> form (not converting it using <code>key_format</code>), sets the key in the new cursor, and does a search to set the position properly.</p>
<h1><a class="anchor" id="arch_cursor_dhandle"></a>
File cursors, Btrees and data handles</h1>
<p>File cursors, Btrees and data handles exist in a WiredTiger system as different ways to reference the data in a Btree. It is useful to understand the differences between these structures and how they are used.</p>
<p>At the bottom is the data handle (also known as <em>dhandle</em>). This is an abstraction of an operating system file handle, with a set of flags and some reference counts. A Btree is a much larger abstraction, with a memory cache of key value pairs along with functions to read and write data as needed to and from the data file. A Btree is paired with a data handle to allow the transfer of data. Both the data handle and the Btree are owned by the connection. That is, they are shared among all sessions.</p>
<p>File cursors, on the other hand, are owned by a session. When a session opens a cursor on a file for the first time in that session, a file cursor is created. This occurs even if the file may be opened by cursors in other sessions already. The session owns the cursor, and the cursor may only be used by that session. Open cursors do increment reference counts in the data handle, so that the data handle "knows" it is being used, so that the file may not be dropped, renamed, verified or salvaged. So when <a class="el" href="struct_w_t___c_u_r_s_o_r.html#aeea071f192cab12245a50fbe71c3460b" title="Close the cursor.">WT_CURSOR::close</a> is called for a file cursor, the cursor's memory may be released (or retained if cached), and reference counts decremented. Other sessions may retain open cursors on that file, they are independent.</p>
<h1><a class="anchor" id="arch_cursor_caching"></a>
Cursor caching</h1>
<p>Cursors, upon closing, may be cached in the session. An open of the same URI will return a cached cursor if one is found matching the URI. Cursor caching is currently only done on file cursors. Because of the optimization for simple tables described above, cursors on simple tables are also cached.</p>
<p>To help implement caching, two methods, <code>cache</code> and <code>reopen</code> have been added to the cursor API. These are not public. Their function is to perform cursor-type specific operations to change a cursor from an open state to a cached state (<code>cache</code>) and change from a cached state to the open state (<code>reopen</code>).</p>
<p>When a cursor is opened the first time, it is marked as <em>cacheable</em> or not. Cursors that specify certain options, like bulk loading, random, or readonly, are not cacheable. When a cursor is closed, the cursor is checked if it is cacheable. If so and if cursor caching is enabled in the session, then it will be cached. Cached cursors live in a hash table that is owned by the session. A hash function on the URI is used to determine which hash bucket to use. We compute the hash of the URI once, its value is stored in in the cursor for future use. Thus, caching a cursor (what happens within the type-specific <code>cache</code> function (e.g. <code>__curfile_cache</code>) is relatively quick:</p>
<ul>
<li>Free storage that we don't want held (for example, storage used by the cursor's key and value).</li>
<li>Get a <em>weak</em> reference to the data handle (increment <code>dhandle-&gt;references</code>).</li>
<li>Release the <em>strong</em> reference to the data handle (decrement <code>dhandle-&gt;session_inuse</code>).</li>
<li>Determine the hash bucket needed (using the hash value in the cursor).</li>
<li>Move the cursor from the session's open list to the list in the hash bucket.</li>
<li>Increment statistics and decrement the connection's open cursor count.</li>
<li>Set the cache cursor flag.</li>
<li>Unlock the dhandle.</li>
</ul>
<p>The change of reference from a <em>strong</em> to a <em>weak</em> is significant. When a dhandle's <code>session_inuse</code> (<em>strong</em> reference) drops to zero, it means that no cursor is open on the dhandle, and the only references are from cached cursors. In this state, the dhandle may be marked dead by the dhandle sweep. When the dhandle is dead, the dhandle's memory will still persist, but each session will eventually notice, during its cursor cache sweep, and "fully close" the cursor, removing it from the cache list, releasing its weak reference before freeing the cursor. Each session holding cached cursors must have some periodic activity that causes it to run its sweep, an occasional call to <a class="el" href="struct_w_t___s_e_s_s_i_o_n.html#a307800663ed211447a18c46863c28787" title="Reset the session handle.">WT_SESSION::reset</a> will suffice. After a dhandle has been dead for enough time, it is expected that all of its weak references will drop to zero, and the dhandle itself can be freed by the dhandle sweep.</p>
<p>If there is a failure during the <code>cache</code> function, then we would want to fully close the cursor. Rather than having special case code to handle this rare condition, we instead call <code>reopen</code> to temporarily bring the cursor back to an open state, and turn cursor caching off temporarily in the session while we close the cursor, releasing all its resources and references.</p>
<p>During a cursor open, if the cursor configuration options allow caching, we hash the uri, and look at the corresponding hash bucket in the session cursor cache. If we find a matching cursor, we call <code>reopen</code> on the cursor. This is what happens within the call to the type-specific <code>reopen</code> function (e.g. <code>__curfile_reopen</code>):</p>
<ul>
<li>Lock the dhandle.</li>
<li>If the dhandle is no longer open, release it and mark the reopen to fail (but continue).</li>
<li>Get a "strong" reference to the data handle (increment <code>dhandle-&gt;session_inuse</code>).</li>
<li>Release the "weak" reference to the data handle (decrement <code>dhandle-&gt;references</code>).</li>
<li>Increment statistics and the connection's open cursor count.</li>
<li>Move the handle from the hash bucket to the session's open list (the hash value was previously saved in the cursor)</li>
<li>Clear the cache cursor flag.</li>
<li>Update convenient pointers within the cursor to parts of the WT_BTREE that may have changed which the cursor was cached.</li>
</ul>
<p>If the reopen fails (probably due to the dhandle no longer being open or being marked dead), we have ensured that enough of the cursor is opened so that it can be legally closed. We have studiously avoided having a cursor that is in some state that is half-open and half-closed, as it is hard to know how to dispose of it.</p>
<h1><a class="anchor" id="arch_cursor_sweep"></a>
Session cursor sweep</h1>
<p>Consider a large system that has many sessions using the same set of tables. When all sessions have closed a particular table, there will be no need to keep the underlying data handle open. In fact, if a <a class="el" href="struct_w_t___s_e_s_s_i_o_n.html#adf785ef53c16d9dcc77e22cc04c87b70" title="Drop (delete) a table.">WT_SESSION::drop</a> call is called, we want to ensure that the data handle has been closed and the corresponding file is removed. Some systems, like Windows, require that all open file handles be closed before a file can be successfully removed from the file system. So there is motivation to periodically mark data handles that have no active references, and have sessions free cached cursors that have weak references to such marked data handles. The former job occurs in the connection sweep code. The latter job occurs in the session cursor cache sweep.</p>
<p>The session cursor cache sweep currently happens in the <a class="el" href="struct_w_t___c_u_r_s_o_r.html#aeea071f192cab12245a50fbe71c3460b" title="Close the cursor.">WT_CURSOR::close</a> call, and also on calls to <a class="el" href="struct_w_t___s_e_s_s_i_o_n.html#a307800663ed211447a18c46863c28787" title="Reset the session handle.">WT_SESSION::reset</a>. On one hand, we don't want the overhead of a sweep to occur too frequently. It is quite possible that both close and reset can be called a lot and there may be many of thousands of cached cursors in the session. For that reason, we'd like to do the sweep in small increments, and not on each call. On the other hand, in a larger system, a session may be part of a pool servicing higher level requests. When a session completes its work, it may be left idle by the caller of WiredTiger, and such a session may then be idle for long periods of time. When cursor caching is enabled and sessions are not active, we want even occasional calls to <a class="el" href="struct_w_t___s_e_s_s_i_o_n.html#a307800663ed211447a18c46863c28787" title="Reset the session handle.">WT_SESSION::reset</a> to have a strong effect. We want occasional sweeps to keep up with freeing up references to data handles, so that otherwise unused data handles may in turn be freed eventually.</p>
<p>Our solution to this is three-fold. First, every time we want to call the sweep, a countdown counter is used, so we only consider a sweep every <code>WT_SESSION_CURSOR_SWEEP_COUNTDOWN</code> times (currently <code>WT_SESSION_CURSOR_SWEEP_COUNTDOWN == 40</code>). Secondly, we won't sweep if it's already been done this second in time. Finally, we sweep by walking a small set of buckets, initially 5 out of typically 512 configured buckets. However, depending on how productive our sweep is, that is, how many references to closed data handles are freed, we may continue our walk. This should usually strike a good balance between not having a lot of overhead for sweeps, and keeping up with the need to free up shared resources.</p>
<h1><a class="anchor" id="arch_cursor_bound"></a>
Range bounded cursors</h1>
<p>Range bounded cursors provide a mechanism for optimizing cursor operations in collections with a large number of invisible records. When traversing records the record's key is compared with the bounds set on the cursor and the traversal will exit with <code>WT_NOTFOUND</code> regardless of whether the value associated with the cursor is visible.</p>
<p>The lower and upper bound in a cursor is represented as a <code><a class="el" href="group__wt.html#struct_w_t___i_t_e_m" title="A raw item of data to be managed, including a pointer to the data and a length.">WT_ITEM</a></code>. The implementation applies bounds through the function <code>__wt_cursor_bound</code> which takes the cursor and a config string as arguments. The config string specifies whether the operation is clearing or setting the bound, and if a "set" is in progress, whether the bound is a lower or upper bound. There are four flags that can be set when applying bounds: <code>WT_CURSTD_BOUND_LOWER</code>, <code>WT_CURSTD_BOUND_LOWER_INCLUSIVE</code>, <code>WT_CURSTD_BOUND_UPPER</code>, and <code>WT_CURSTD_BOUND_UPPER_INCLUSIVE</code>. When calling <code>__wt_cursor_bound</code> with valid bounds, the respective bound flag is set and the key held on the cursor is copied into the relevant bound buffer. When a bounds is set, a copy of the bounds key is made and is kept by the cursor. Thus the memory used for the key when making the <code>cursor-&gt;bound</code> call does not need to be retained by the application. Clearing a cursor's bounds can be done via resetting the cursor or calling bound with the "clear" config which will free both bounds buffers.</p>
<p>When calling <code>cursor-&gt;next</code> and <code>cursor-&gt;prev</code> on an unpositioned cursor, WiredTiger guarantees that the cursor will start walking from either the start or end of the file respectively. The range bounded cursor logic continues to uphold this guarantee. Doing so requires additional logic to place the cursor at the start or end of the range. In <code>cursor-&gt;next</code> and <code>cursor-&gt;prev</code>, the cursor gets positioned with the function <code>__wt_btcur_bounds_position</code>. This attempts to position the cursor on the appropriate bound for the direction of traversal (e.g. lower bound for next). If the bound exists, the cursor will be positioned on the bound, if not it could be positioned on the closest valid record (meaning within the bounded range), or the record just outside of the range. In the case it's positioned just outside the range, this is still acceptable as it will be marked as "needing walk", and the following traversal (whether next or prev) will continue, returning a record within range at completion.</p>
<p>In <code>cursor-&gt;search_near</code>, <code>__btcur_bounds_search_near_reposition</code> is initially called. This function checks whether the given key to be searched for is within the bounded range. If not, the key to be searched for will be updated to be the nearest bound.</p>
<h1><a class="anchor" id="arch_cursor_debug_copy"></a>
Debug copy</h1>
<p>When cursors are positioned, their data may point to data in the btree or data allocated in the cursor. A caller may use a pointer to that data until the next cursor call. After that, the pointer should not be considered valid. By default, WiredTiger does not enforce this. When opening a cursor, a <code>"debug=copy"</code> configuration flag can be used. This forces any data that is returned by <a class="el" href="struct_w_t___c_u_r_s_o_r.html#af19f6f9d9c7fc248ab38879032620b2f" title="Get the key for the current record.">WT_CURSOR::get_key</a> or <a class="el" href="struct_w_t___c_u_r_s_o_r.html#af85364a5af50b95bbc46c82e72f75c01" title="Get the value for the current record.">WT_CURSOR::get_value</a> to be in malloc'd memory, and explicitly freed on the next API call. Systems that are instrumented to track memory references can detect the references to freed memory, thus latent bugs can be detected.</p>
<p>The implementation is straightforward. The key and value in each cursor is represented as a <code><a class="el" href="group__wt.html#struct_w_t___i_t_e_m" title="A raw item of data to be managed, including a pointer to the data and a length.">WT_ITEM</a></code>. A <code><a class="el" href="group__wt.html#struct_w_t___i_t_e_m" title="A raw item of data to be managed, including a pointer to the data and a length.">WT_ITEM</a></code> includes a pointer and size, and it can point to arbitrary memory. However, the <code><a class="el" href="group__wt.html#struct_w_t___i_t_e_m" title="A raw item of data to be managed, including a pointer to the data and a length.">WT_ITEM</a></code> also includes a memory buffer that may or may not be allocated. When the <code><a class="el" href="group__wt.html#struct_w_t___i_t_e_m" title="A raw item of data to be managed, including a pointer to the data and a length.">WT_ITEM</a></code> pointer points to the item's own memory buffer, then it is already in malloc'd memory. When <code>"debug=copy"</code> is configured, it is a simple matter to check if a key and value being returned are already in the item's malloc'd memory. If not, memory is allocated, the copy is made and the item's pointer is updated. On the beginning of the next API call using that cursor, the item's malloc'd memory is overwritten and freed. Thus, in the presence of a memory tracker, uses of "stray" pointers will be detected. Even without a memory tracker, uses of "stray" pointers into the freed storage will likely yield the overwritten bytes, and not the previously seen key or value.</p>
<h1><a class="anchor" id="arch_random_cursor"></a>
Random Cursor</h1>
<p>WiredTiger uses a pseudo-random algorithm for random cursors with the goal of deriving good random distributions while maintaining performance. Only the <code>cursor-&gt;next</code> function can be used to fetch a random record.</p>
<p>The algorithm starts from the root page being descended down randomly using WiredTiger's random number generator (RNG) until we reach a leaf page. Once we find a leaf page, we then evaluate three different conditions that determine our next steps to grab a record from the leaf page.</p><ul>
<li>First condition: If the page has a sufficiently large number of disk records (1000 or more entries), attempt to find a random visible disk record from the page using WiredTiger's RNG.</li>
<li>Second condition: Loop through all insert lists, and find one that is large (1000 or more entries), once found attempt to find a random insert record from the page.</li>
<li>Third condition: If the page has small amount of disk records (200 or less entries) or the leaf page is clean, attempt to find a random visible disk record from the page using WiredTiger's RNG.</li>
</ul>
<p>Failing all of the conditions, move to the previous or the next visible record in the btree a randomly decided number of times (between 0 - 250). Return the record that the cursor ends up stopping on. Note: The record can be fetched on a different leaf page than our original page that we descended down from.</p>
<p>The algorithm doesn't guarantee a complete randomness to the user and can lead to skewed results depending on the underlying tree structure. Examples of instances that could typically lead to these skewed results are:</p><ul>
<li>The tree structure is not balanced, which can happen as a result of the records in the btree not being uniformly distributed.</li>
<li>A high number of deleted items are within the btree.</li>
<li>A high number of invisible records in the transaction of the cursor.</li>
</ul>
<p>The <code>next_random_sample_size</code> configuration is an option that can be used for users looking for a better distribution. The concept is that the btree becomes divided into <code>next_random_sample_size</code> pieces, and each subsequent <code>cursor-&gt;next</code> call will retrieve a random record from the following divided piece. Internally, this configuration results in a slight modification to the original pseudo-random algorithm described at the start of this section. The process remains the same except for Step 1, where instead of performing a random descent, the algorithm will now start from the beginning of the btree and traverse a fixed number of times to next the divided segment. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div class="ttc" id="astruct_w_t___s_e_s_s_i_o_n_html_a358ca4141d59c345f401c58501276bbb"><div class="ttname"><a href="struct_w_t___s_e_s_s_i_o_n.html#a358ca4141d59c345f401c58501276bbb">WT_SESSION::create</a></div><div class="ttdeci">int create(WT_SESSION *session, const char *name, const char *config)</div><div class="ttdoc">Create a table, column group, index or file.</div></div>
<div class="ttc" id="astruct_w_t___s_e_s_s_i_o_n_html_afb5b4a69c2c5cafe411b2b04fdc1c75d"><div class="ttname"><a href="struct_w_t___s_e_s_s_i_o_n.html#afb5b4a69c2c5cafe411b2b04fdc1c75d">WT_SESSION::open_cursor</a></div><div class="ttdeci">int open_cursor(WT_SESSION *session, const char *uri, WT_CURSOR *to_dup, const char *config, WT_CURSOR **cursorp)</div><div class="ttdoc">Open a new cursor on a data source or duplicate an existing cursor.</div></div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">Reference Guide</a></li><li class="navelem"><a class="el" href="arch-index.html">WiredTiger Architecture Guide</a></li><li class="navelem"><a class="el" href="arch-toc-fundamentals.html">Fundamentals</a></li>
    <li class="footer">Copyright (c) 2008-present MongoDB, Inc.  All rights reserved.  Contact <a href="mailto:info@wiredtiger.com">info@wiredtiger.com</a> for more information.</li>
  </ul>
</div>
</body>
</html>
