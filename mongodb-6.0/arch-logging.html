<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>WiredTiger: Logging</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="sorttable.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="wiredtiger.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://wiredtiger.com/"><img alt="Logo" src="LogoFinal-header.png" alt="WiredTiger" /></a></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Version 10.0.2</span>
   </div>
   <div id="projectbrief"><!-- 10.0.2 --></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<div class="banner">
  <a href="https://github.com/wiredtiger/wiredtiger">Fork me on GitHub</a>
  <a class="last" href="http://groups.google.com/group/wiredtiger-users">Join my user group</a>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('arch-logging.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Logging </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><div class="arch_head"><table class="doxtable">
<tr>
<th rowspan="2" style="width:10%;"> <div><a href="arch-index.html"><img class="arch_thumbnail" src="wt_diagram.png" usemap="#wt_diagram_map" style="background-image: url(wt_diagram.png)"></a></div></th><th style="width:44%">Data Structures</th><th style="width:45%">Source Location</th></tr>
<map id="wt_diagram_map" name="wt_diagram_map">
<area shape="rect" id="id1" href="modules.html" title="modules.html" alt="" coords="248,128,283,144"/>
<area shape="rect" id="id2" href="arch-cache.html" title="arch-cache.html" alt="" coords="204,546,248,562"/>
<area shape="rect" id="id3" href="arch-cursor.html" title="arch-cursor.html" alt="" coords="234,224,280,240"/>
<area shape="rect" id="id4" href="arch-eviction.html" title="arch-eviction.html" alt="" coords="303,546,356,562"/>
<area shape="rect" id="id5" href="arch-logging.html" title="arch-logging.html" alt="" coords="388,650,443,666"/>
<area shape="rect" id="id6" href="arch-schema.html" title="arch-schema.html" alt="" coords="123,224,179,240"/>
<area shape="rect" id="id7" href="command_line.html" title="command_line.html" alt="" coords="374,23,430,39"/>
<area shape="rect" id="id8" href="arch-log-file.html" title="arch-log-file.html" alt="" coords="308,865,339,897"/>
<area shape="rect" id="id9" href="arch-metadata.html" title="arch-metadata.html" alt="" coords="25,328,89,344"/>
<area shape="rect" id="id10" href="arch-python.html" title="arch-python.html" alt="" coords="84,23,157,39"/>
<area shape="rect" id="id11" href="arch-snapshot.html" title="arch-snapshot.html" alt="" coords="297,441,371,457"/>
<area shape="rect" id="id12" href="arch-transaction.html" title="arch-transaction.html" alt="" coords="298,328,387,344"/>
<area shape="rect" id="id13" href="arch-hs.html" title="arch-hs.html" alt="" coords="93,642,140,674"/>
<area shape="rect" id="id14" href="arch-block.html" title="arch-block.html" alt="" coords="196,642,256,674"/>
<area shape="rect" id="id15" href="arch-dhandle.html" title="arch-dhandle.html" alt="" coords="144,320,205,352"/>
<area shape="rect" id="id16" href="arch-data-file.html" title="arch-data-file.html" alt="" coords="179,865,245,897"/>
<area shape="rect" id="id17" href="arch-row-column.html" title="arch-row-column.html" alt="" coords="117,433,205,465"/>
<area shape="rect" id="id18" href="arch-fs-os.html" title="arch-fs-os.html" alt="" coords="175,755,357,771"/>
</map>
<tr>
<td><code><code>WT_CURSOR_LOG<br  />
WT_LOG<br  />
WT_LOGSLOT<br  />
WT_LOG_RECORD<br  />
WT_LSN</code></code></td><td><code><code>src/include/log.h<br  />
src/include/log_inline.h<br  />
src/log/</code></code></td></tr>
</table>
</div><p> <b>Caution: the Architecture Guide is not updated in lockstep with the code base and is not necessarily correct or complete for any specific release.</b></p>
<p>The WiredTiger logging subsystem implements a write-ahead log when configured. It is a central resource recording changes made to different tables, by different threads, into a file on disk. Its purpose is so that changes made since the most recent checkpoint are not lost and can be recovered on restart after a crash (unclean shutdown).</p>
<h1><a class="anchor" id="log_files"></a>
Log-related files in the database directory</h1>
<p>There are three log-related file variants that users can see in the database directory: <code>WiredTigerLog</code>.*, <code>WiredTigerPreplog</code>.* and <code>WiredTigerTmplog</code>.*. The actual write-ahead log files are prepended with the string <code>WiredTigerLog</code>. followed by ten digits of log file number. For example, <code>WiredTigerLog.0000000001</code>. The other two log-related filenames are for log file pre-allocation. When pre-allocation is configured (the default), new log files are created ahead of time containing the log file header content and are ready in the directory for use. The header content is written into a temporary file with the prefix <code>WiredTigerTmplog</code>. and again followed by a number. Once the temporary file is completely filled with the required content, synced to disk and closed, it is renamed to a prepared log file that other threads in the system can rename to use as the next real log file. Prepared pre-allocated log files that are ready to use have the prefix <code>WiredTigerPreplog</code>.</p>
<p>Only the numbering of the actual <code>WiredTigerLog</code>.* files is significant. There is no relation between the numbers on those files and the number of the pre-allocated files. For pre-allocation, unique names are needed to avoid any possibility of naming collision and the numbering mechanism exists, so the code reuses it. But there is no meaning to the numbers on the two pre-allocated file types.</p>
<p>There are a varying number of temporary and prepared log files in the directory. They are removed immediately on startup. Old pre-allocated log files cannot be reused on a restart because the log format and WiredTiger software could have changed in between runs. See <a class="el" href="arch-logging.html#log_threads">Internal Threads</a> for a discussion of pre-allocation.</p>
<h1><a class="anchor" id="log_configuration"></a>
Configuration choices and their implications</h1>
<p>Once the logging subsystem is enabled for the system, then other configuration settings control the finer details of the logging subsystem. The <code>remove=true</code> setting turns on automatic log file removal. That means that log files earlier than the most recently completed checkpoint are removed. There are times, even when configured on, that automatic log removal is temporarily disabled inside the WiredTiger library.</p>
<p>Log removal is disabled when a backup cursor is open. WiredTiger must guarantee that any log file name that may have been returned to a backup cursor remains in existence for the lifetime of that cursor. Log removal is also disabled when a log cursor is open. This cursor could be positioned anywhere in the log that existed when the cursor was opened and walking the records, so all log files that existed at open must continue to exist.</p>
<p>The (default) log file pre-allocation setting <code>prealloc=true</code> allows the system to pre-allocate log files so that when application threads are writing their log records, on the critical path, they do not incur the penalties of file creation and having to sync the header or directory to the disk. Similar to automatic removal, there are times when log file pre-allocation is disabled internally. Pre-allocation is disabled when a backup cursor is open. The user may not walk the list of files returned in the backup cursor, but can, instead, copy the directory contents itself. Therefore, backup has a contract that all files that existed when the backup cursor was opened will continue to exist for the lifetime of the backup cursor. Renaming pre-allocated log files would violate that contract.</p>
<h1><a class="anchor" id="log_records"></a>
Log operations and records</h1>
<p>The unit written to the write-ahead log is a log record. Some log records are made up of log operations. The most common log record containing operations is the transaction commit log record. Log records are of type <code>WT_LOG_RECORD</code>. There is a 16-byte header that contains information about this record such as its length on disk, its length in memory, a record checksum and whether it is compressed or encrypted. Then the end of the log record contains the data for the that record. All log records are a multiple of 128 bytes. The reason for that was to avoid any false memory sharing when writing records into a memory buffer.</p>
<p>Log operations describe the changes in a transaction. Modifications are collected in a memory buffer in a transaction and then when the transaction commits, that set of operations is given to the logging subsystem to write as a single commit log record. Therefore, transactions consume memory with that buffer as long as the transaction is active. The other implication of using this operations buffer is that it is simply freed if the transaction is rolled back and there is nothing to record or do for a rolled back transaction.</p>
<h1><a class="anchor" id="log_subsystem"></a>
Logging subsystem data structures and algorithms</h1>
<p>A log sequence number (LSN) identifies the location of a log record. In WiredTiger, the LSN is a 64-bit number containing two values, a 32-bit file number and a 32-bit offset. The file number portion of the LSN maps to the number in the <code>WiredTigerLog</code>. file name. The offset portion of the LSN is the byte offset within that file where the log record starts.</p>
<p>There is a <code>WT_LOG</code> structure that contains the live information about the state of the logging subsystem. This document does not itemize every field. It contains some locks and condition variables for synchronization and a large set of LSNs for keeping track of the state of the system. Some of the important LSNs maintained are:</p><ul>
<li>alloc_lsn: This is the LSN for the next log record allocation.</li>
<li>ckpt_lsn: This is the LSN of the last checkpoint.</li>
<li>sync_lsn: This is the LSN of the last record synced to disk.</li>
<li>write_lsn: This is the LSN of the end of the last record written to the operating system.</li>
<li>write_start_lsn: This is the LSN of the start of the last record written to the operating system.</li>
</ul>
<p>As mentioned earlier, all log records are a multiple of 128 bytes, and that means they also have a 128 byte minimum record size. If a buffer is not a multiple, the logging subsystem allocates a 128-byte multiple rounded up buffer and copies the record into that buffer and zero fills the tail.</p>
<p>Logging supports both compression and at-rest encryption. When compression is enabled, WiredTiger only compresses if doing so may result in space savings. Therefore, small records that already are below the 128 byte minimum size will not result in any space savings. All user log records are encrypted when enabled, regardless of size. When both compression and encryption are enabled, compression is performed first, then encryption. That resulting log record is then rounded up to the 128-byte multiple.</p>
<p>WiredTiger uses a lock free mechanism to write records to the log in the common path. WiredTiger has a pool of log buffers called slots and each thread entering the logging code reserves its memory buffer via atomic operations and then fills in its part of the memory. When all threads that are using the slot finish their copies into the memory, then the slot can be released and written to the file system. Slots remain open and the memory available for the next thread to use until a flush is forced, the memory fills or a timer expires.</p>
<p>This means that for the common case of a user committing a transaction with the default synchronization setting of memory-only, the path of writing its record into the write-ahead log becomes, essentially, two atomic operations and memory copies. The common path does not require acquiring locks.</p>
<h1><a class="anchor" id="log_threads"></a>
Internal Threads</h1>
<p>There are several internal logging-related threads that perform housekeeping on the logging subsystem. The main thread, called <code>log_server</code>, is a general thread, meaning it performs several unrelated tasks. It flushes out the current slot to the file system. It does this flush every 50 milliseconds and this is done so that if a system becomes idle, buffered log records in the memory of a slot do not languish. The thread also performs log removal to discard any log files that are no longer needed based on the checkpoint LSN. Finally the main thread performs log file pre-allocation, if configured. The pre-allocation algorithm is adaptable. If the thread did not make sufficient numbers of pre-allocated log files the system then makes more. If too few were used, then later pre-allocation will create fewer of them.</p>
<p>There is another internal thread dedicated to managing operations on log files. This is the <code>log_file_server</code> thread. I/O operations can be slow and costly so this thread takes the burden of closing and syncing files to disk off of user application threads. If a log file needs to be closed, then the application thread moves its file handle to the <code>log-&gt;log_close_fh</code> field and signals this thread. This thread will fsync the file handle, and then close it. Updating the <code>log_close_lsn</code> and the <code>sync_lsn</code> values when those I/O operations are complete.</p>
<p>The third internal thread manages advancing the <code>write_lsn</code>. As the <code>write_lsn</code> must be advanced in proper LSN order, it becomes a point of single threading in the path of writing a log record. The goal is to avoid single threading application threads. So after a log slot is written to the file system, the application thread only needs to set the slot's state to a special state <code>WT_LOG_SLOT_WRITTEN</code> and return. This internal thread then walks the array of log slots looking for written slots and advances the <code>write_lsn</code> in the proper order. Along the way the thread will coalesce adjacent LSNs of slots in order to advance the LSN in larger increments. This thread will then clean up and mark the state of the processed slots as <code>WT_LOG_SLOT_FREE</code>.</p>
<h1><a class="anchor" id="log_usage"></a>
Using the log</h1>
<p>In addition to storing a record of the operations performed to data in the write-ahead log, users can write their own strings into the logs via the <code><a class="el" href="struct_w_t___s_e_s_s_i_o_n.html#ac85541ca42d7596857d9f50e03c78eb5" title="Insert a WT_LOGREC_MESSAGE type record in the database log files (the database must be configured for...">WT_SESSION::log_printf</a></code> method. That method takes a printf-style format string and arguments and will write that string into the write-ahead log as a message record type.</p>
<p>Transactions are stored in the write-ahead log and their purpose is to allow recovery in the case of crash or failure. When the system is restarted, WiredTiger will always run recovery. If the system previously shutdown cleanly, then recovery determines that the log does not need to be replayed. Otherwise, recovery replays all operations from the LSN of the most recent checkpoint. When timestamps are in use, recovery also performs a <a class="el" href="arch-rts.html">rollback to stable</a> operation on tables that are not logged.</p>
<p>Users can access and view the records in the log using one of two methods. The most common method is via the <code>wt</code> printlog command. The command utility will print the entire log by default. The user can specify optional starting and ending LSNs on the command line to limit the output. See <a class="el" href="command_line.html">WiredTiger command line utility</a> for more information.</p>
<p>A log cursor can be opened up on a running system and that cursor can walk forward through the log. Log cursors are described in great detail on the <a class="el" href="cursor_log.html">Log cursors</a> page. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">Reference Guide</a></li><li class="navelem"><a class="el" href="arch-index.html">WiredTiger Architecture Guide</a></li><li class="navelem"><a class="el" href="arch-toc-recovery.html">Recovery</a></li>
    <li class="footer">Copyright (c) 2008-present MongoDB, Inc.  All rights reserved.  Contact <a href="mailto:info@wiredtiger.com">info@wiredtiger.com</a> for more information.</li>
  </ul>
</div>
</body>
</html>
