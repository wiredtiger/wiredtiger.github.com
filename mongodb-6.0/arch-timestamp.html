<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>WiredTiger: Timestamps</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="sorttable.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="wiredtiger.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://wiredtiger.com/"><img alt="Logo" src="LogoFinal-header.png" alt="WiredTiger" /></a></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Version 10.0.2</span>
   </div>
   <div id="projectbrief"><!-- 10.0.2 --></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<div class="banner">
  <a href="https://github.com/wiredtiger/wiredtiger">Fork me on GitHub</a>
  <a class="last" href="http://groups.google.com/group/wiredtiger-users">Join my user group</a>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('arch-timestamp.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Timestamps </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><div class="arch_head"><table class="doxtable">
<tr>
<th rowspan="2" style="width:10%;"> <div><a href="arch-index.html"><img class="arch_thumbnail" src="wt_diagram.png" usemap="#wt_diagram_map" style="background-image: url(wt_diagram.png)"></a></div></th><th style="width:44%">Data Structures</th><th style="width:45%">Source Location</th></tr>
<map id="wt_diagram_map" name="wt_diagram_map">
<area shape="rect" id="id1" href="modules.html" title="modules.html" alt="" coords="248,128,283,144"/>
<area shape="rect" id="id2" href="arch-cache.html" title="arch-cache.html" alt="" coords="204,546,248,562"/>
<area shape="rect" id="id3" href="arch-cursor.html" title="arch-cursor.html" alt="" coords="234,224,280,240"/>
<area shape="rect" id="id4" href="arch-eviction.html" title="arch-eviction.html" alt="" coords="303,546,356,562"/>
<area shape="rect" id="id5" href="arch-logging.html" title="arch-logging.html" alt="" coords="388,650,443,666"/>
<area shape="rect" id="id6" href="arch-schema.html" title="arch-schema.html" alt="" coords="123,224,179,240"/>
<area shape="rect" id="id7" href="command_line.html" title="command_line.html" alt="" coords="374,23,430,39"/>
<area shape="rect" id="id8" href="arch-log-file.html" title="arch-log-file.html" alt="" coords="308,865,339,897"/>
<area shape="rect" id="id9" href="arch-metadata.html" title="arch-metadata.html" alt="" coords="25,328,89,344"/>
<area shape="rect" id="id10" href="arch-python.html" title="arch-python.html" alt="" coords="84,23,157,39"/>
<area shape="rect" id="id11" href="arch-snapshot.html" title="arch-snapshot.html" alt="" coords="297,441,371,457"/>
<area shape="rect" id="id12" href="arch-transaction.html" title="arch-transaction.html" alt="" coords="298,328,387,344"/>
<area shape="rect" id="id13" href="arch-hs.html" title="arch-hs.html" alt="" coords="93,642,140,674"/>
<area shape="rect" id="id14" href="arch-block.html" title="arch-block.html" alt="" coords="196,642,256,674"/>
<area shape="rect" id="id15" href="arch-dhandle.html" title="arch-dhandle.html" alt="" coords="144,320,205,352"/>
<area shape="rect" id="id16" href="arch-data-file.html" title="arch-data-file.html" alt="" coords="179,865,245,897"/>
<area shape="rect" id="id17" href="arch-row-column.html" title="arch-row-column.html" alt="" coords="117,433,205,465"/>
<area shape="rect" id="id18" href="arch-fs-os.html" title="arch-fs-os.html" alt="" coords="175,755,357,771"/>
</map>
<tr>
<td><code><code>WT_TIME_AGGREGATE<br  />
WT_TIME_WINDOW</code></code></td><td><code><code>src/include/timestamp.h<br  />
src/include/timestamp_inline.h</code></code></td></tr>
</table>
</div><p> <b>Caution: the Architecture Guide is not updated in lockstep with the code base and is not necessarily correct or complete for any specific release.</b></p>
<h1><a class="anchor" id="arch-timestamp-model"></a>
Timestamp data model and worldview</h1>
<p>[This is all in terrible scattershot order and needs to be redone, but should probably finish a full draft before reworking it.]</p>
<p>In the timestamped world, the timing and ordering of commits is under application control. This requires that the application's time be made explicit, as opposed to being the same as wall-clock time as the application executes. Timestamps are points in application time. We shall refer to wall-clock time as the application executes as "execution time". Application time generally correlates with execution time, but there is not necessarily any close equivalence. We expect that the application's time generally rolls forward and that the range of application times that need to be considered at any point during execution is bounded. The design is not intended to provide arbitrary time travel; nor does it allow branching timelines, though there is some ability to rewind.</p>
<p>Thus, at any point during execution there is a window of application time under consideration, which this page will refer to as the "active
time window". This window is divided into two parts: the <em>stable</em> portion, in which the composition of the data is fixed, further write operations are prohibited, and all updates are fully durable; and the <em>unstable</em> portion, in which changes to the data are still being accumulated, write operations are ongoing, and updates may be committed and even checkpointed but are not yet fully durable. Reading from the unstable portion of the time window is not prohibited, but if done incautiously can lead to data inconsistency.</p>
<p>The application controls the active time window by manipulating two global timestamps: the <em>oldest</em> timestamp and the <em>stable</em> timestamp. The <em>oldest</em> timestamp gives the earliest point in application time where the application can/will start new transactions reading. Attempting to read before this point is an application error. The <em>stable</em> timestamp defines the point that divides the stable part of the time window from the unstable part. The front/future end of the time window is represented by the latest timestamp that has been used so far; this is, however. not explicitly managed or tracked. The application is free to advance time by whatever jumps it wishes.</p>
<p>Internally, WiredTiger tracks an additional bound, the <em>pinned</em> timestamp: this is the minimum over the oldest timestamp and the read timestamps of all running transactions. This is the "real" lower bound of the active time window, used for all operations that involve dropping or garbage-collecting data that has aged out. This ensures that the application can update the oldest timestamp without compromising operations already in progress.</p>
<p>Within the active time window, each read or write operation (removes count as writes) is performed at some given application time. As always, operations are grouped into transactions, and in keeping with the principle that transactions are atomic, times are attached to transactions, both conceptually and in the API. Each transaction has a <em>read</em> timestamp, which is the application time used for read operations, and a <em>commit</em> timestamp, which is the application time used for write operations. (Prepared transactions also have a <em>prepare</em> timestamp and a <em>durable</em> timestamp, which are elaborations of the commit timestamp; see <a class="el" href="arch-timestamp.html#arch-timestamp-prepare">Prepared transactions</a>.)</p>
<p>Each change to a given database item's value is thus associated with a timestamp. Consequently, values themselves are associated with ranges of time. These are called <em>time windows</em>, not to be confused with the overall active time window of the database. The value of a database item <em>starts</em> when it is first written (in application time) and <em>stops</em> when it is next overwritten or removed. For any key present in the database there exists some sequence of values, each ranging from some start time to some stop time. This sequence is not necessarily contiguous (we do not treat "deleted" as a first class value; it is the absence of any other value) but the ranges are not permitted to overlap. Stop times are not inclusive; that is, when a value is overwritten its stop time is the same as the next value's start time, and reads at that time will yield the new value.</p>
<p>Because the portion of the active time window beyond the stable timestamp is considered provisional, it is discarded at key points: as part of recovery during startup, on shutdown, and also at any time the application wishes by calling <a class="el" href="struct_w_t___c_o_n_n_e_c_t_i_o_n.html#a93dbc74accb426582b3c5c2f69e04b28" title="Rollback tables to an earlier point in time, discarding all updates to checkpoint durable tables that...">WT_CONNECTION::rollback_to_stable</a>.</p>
<p>Reads and writes continue to use the transaction system and in particular continue to operate using snapshot isolation. Reads will only see updates committed as of when the read transaction's snapshot was taken, regardless of the relationship of their commit timestamps to the read transaction's read timestamps. If reading beyond the stable timestamp, it is thus possible for one transaction to commit into another transaction's past, which violates consistency. Applications are expected to avoid this: in general all commit timestamps should be greater than all read timestamps, whether or not the dividing line is the same as the stable timestamp.</p>
<p>Non-timestamped reads in timestamped tables are permitted and proceed using ordinary snapshot isolation. This will always read the latest (in application time) committed values, and is therefore particularly susceptible to the inconsistency described in the preceding paragraph.</p>
<p>Non-timestamped writes in timestamped tables are also permitted. These create new values that begin at the beginning of time, retroactively (in execution time) replacing the entire prior value sequence once committed. (Snapshot isolation still applies, however: readers whose snapshots predate the non-timestamped write will continue to see the prior database state until they commit or get a new snapshot.)</p>
<p>Applications are expected to write the value sequence in order; that is, for each key in the database, every write should commit with a timestamp later than the latest existing timestamp for that key. This is currently not enforced; because MongoDB sometimes issues out of order updates, they must for the time being be handled.</p>
<h1><a class="anchor" id="arch-timestamp-representation"></a>
Representation of timestamps and time windows</h1>
<p>Internally, timestamps are 64-bit unsigned integers, where 0 is reserved and increasing values correspond to later time. WiredTiger does not otherwise interpret the values of timestamps and they need not be real time or any clock time; sequential counters are perfectly satisfactory. The symbolic values <code>WT_TS_NONE</code> and <code>WT_TS_MAX</code> give 0 and the maximum possible timestamp, respectively.</p>
<p>Timestamps are exchanged with the application as strings, printed in hex without a leading <code>0x</code>, and not as machine integers. (This is because they are handled using the configuration parameter system, which is string-based.)</p>
<p>Time <em>windows</em> are handled in memory using the struct type <code>WT_TIME_WINDOW</code>. This contains a start time and a stop time. The type actually has seven members:</p>
<ul>
<li><code>start_ts</code> (the start time)</li>
<li><code>durable_start_ts</code> (also the start time)</li>
<li><code>start_txn</code> (the transaction ID that committed the start of the value)</li>
<li><code>stop_ts</code> (the stop time)</li>
<li><code>durable_stop_ts</code> (also the stop time)</li>
<li><code>stop_txn</code> (the transaction ID that committed the stop/end of the value)</li>
<li><code>prepare</code> (the transaction-prepare state of the value)</li>
</ul>
<p>The prepare state is not properly speaking part of the time window, but it is also a property of the value and needs to be seen at most of the same points, and in particular also needs to be stored on disk along with the time information, so is kept in the time window structure for convenience.</p>
<p>The distinction between <code>start_ts</code> and <code>durable_start_ts</code> (and between <code>stop_ts</code> and <code>durable_stop_ts</code>) is the same as the distinction between a transaction's commit timestamp and its durable timestamp. See <a class="el" href="arch-timestamp.html#arch-timestamp-prepare">Prepared transactions</a>.</p>
<p>Start times from at or before the pinned timestamp are all equivalent to "no start time" and can be represented as <code>WT_TS_NONE</code>. Similarly, transaction IDs from past write generations should not be retained and are represented as <code>WT_TXN_NONE</code>.</p>
<p>A value that is current and has not been overwritten or deleted has no stop time. This is represented with <code>WT_TS_NONE</code> in <code>durable_stop_ts</code> but <code>WT_TS_MAX</code> in <code>stop_ts</code>, and <code>WT_TS_MAX</code> in <code>stop_txn</code>.</p>
<p>The on-disk representation of the time window of the current on-disk value is an optional part of a value cell. Time windows that are not present are universal (no start time, no stop time); the stop times that mean "no stop time" are not stored. Other stop times are stored as differences from the start time to save space. Similarly, durable timestamps are stored as differences from their corresponding commit timestamps.</p>
<p>The on-disk representation of the time windows of older values are stored differently because those times are used for lookup purposes. See <a class="el" href="arch-hs.html">History Store</a>.</p>
<p>Internal btree pages store aggregated time window information for the pages or sub-trees they reference. This represents, roughly, the union of the time intervals of the data items on the page. It is used to check if a particular timestamp interacts with any on-page items so the page can be skipped over if not. Aggregates are represented in memory by the <code>WT_TIME_AGGREGATE</code> structure, which contains the following elements:</p>
<ul>
<li><code>newest_start_durable_ts</code> (<code>WT_TS_NONE</code> if none)</li>
<li><code>newest_stop_durable_ts</code> (<code>WT_TS_NONE</code> if none, excludes any <code>WT_TS_MAX</code>)</li>
<li><code>oldest_start_ts</code> (<code>WT_TS_NONE</code> if none)</li>
<li><code>newest_txn</code> (<code>WT_TXN_NONE</code> if none, excludes any <code>WT_TS_MAX</code>)</li>
<li><code>newest_stop_ts</code> (<code>WT_TS_MAX</code> if none, including any <code>WT_TS_MAX</code>)</li>
<li><code>newest_stop_txn</code> (<code>WT_TXN_MAX</code> if none, including any <code>WT_TXN_MAX</code>)</li>
<li><code>prepare</code> (whether any prepared values are present)</li>
<li><code>init_merge</code> (flag for how the structure was initialized)</li>
</ul>
<p>These are self-descriptive, except for <code>newest_txn</code>, which is the maximum over the newest start transaction and newest stop transaction. The <code>init_merge</code> flag records whether the structure was initialized for aggregating time windows and merging with other time aggregates; this is used during reconciliation to accumulate the aggregate value to be stored in the parent. (Otherwise, it was not, and those operations are prohibited.)</p>
<p>Aggregation proceeds one time window at a time by taking maxima or minima of the various fields of the aggregate and their corresponding time window fields.</p>
<p>Note that a time aggregate that has been initialized for aggregation without having any time windows aggregated into it is not valid: <code>oldest_start_ts</code> starts at <code>WT_TS_MAX</code>, which is newer than the starting <code>newest_stop_ts</code> of <code>WT_TS_NONE</code>. Consequently, such time aggregates will fail verification. The proper aggregate for an empty page can be produced by aggregating in a single empty time window.</p>
<p>The on-disk representation of a time aggregate is packed into an address cell much as the on-disk representation of a time window is packed into a value cell.</p>
<h1><a class="anchor" id="arch-timestamp-handling"></a>
Handling of timestamps in updates and disk pages</h1>
<p>In memory, when using timestamps, update structures are timestamped with the commit timestamp and durable timestamp. If a commit timestamp has been set when the update is created, it is applied immediately; otherwise it is set along with the durable timestamp at commit time. Non-prepared transactions are also permitted more than one commit timestamp; applying the commit timestamp to updates immediately enables that feature.</p>
<p>In general the commit time of uncommitted updates in the cache may not be known yet and consequently is not used to detect conflicts. (A transaction attempting a write generates a conflict when updates invisible to it appear on the update chain. This causes the write operation to return <a class="el" href="group__wt.html#ga5ee3c6fcd074e11efd118f3e68e91db8" title="Conflict between concurrent operations.">WT_ROLLBACK</a>. Visibility is computed by first using the transaction ID to detect uncommitted changes, and then by checking the read timestamp of the updater against the update's commit timestamp.)</p>
<p>At reconciliation time the visibility code picks the update that should appear on the disk page (generally, the latest committed value; see <a class="el" href="arch-hs.html">History Store</a>) and converts it to a time window. The value's commit time provides the start portion of the time window; if the value is followed by a tombstone, the tombstone provides the stop time, and if it is not, the stop time is set to "none". This time window is then packed into the on-disk value cell along with the value.</p>
<p>When a read needs to examine the on-disk value rather than an update, the unpack logic unpacks the time window as well as the value and proceeds accordingly. Ordinary unpacking (though not the "careful" unpacking used by verify) checks for obsolete transaction IDs that should not be seen (based on write generation) and clears them. This process does not clear old timestamps, however. Old timestamps are cleared explicitly during reconciliation before cell packing.</p>
<h1><a class="anchor" id="arch-timestamp-prepare"></a>
Prepared transactions</h1>
<p>Prepared transactions get two additional timestamps: the <em>prepare</em> timestamp and the <em>durable</em> timestamp. The prepare timestamp is the point at which the transaction is prepared, which can be less than the commit timestamp, and the durable timestamp is the time at which the transaction becomes stable, which can be greater than the commit timestamp. These times are permitted to diverge is so that distributed two-phase commit can reach consensus, which can be slow, without holding up advancement of the stable timestamp. The prepare timestamp must be greater than the stable timestamp as of when the prepare begins, and the durable timestamp must be greater than the stable timestamp as of when the transaction commits.</p>
<p>Reads between the prepare timestamp and commit timestamp of a transaction that has been prepared but not committed fail with <a class="el" href="group__wt.html#ga62f73045c5d37d8daee4533dd720376e" title="Conflict with a prepared update.">WT_PREPARE_CONFLICT</a>.</p>
<p>Reads between the commit timestamp and durable timestamp of a transaction that has been committed but is not yet stable (that is, the stable timestamp is at or past the commit timestamp but has not yet advanced to the durable timestamp) are potentially unsafe. If a second transaction performs such a read and then commits with an <em>earlier</em> durable timestamp, and a checkpoint includes the second transaction's stable timestamp but not the first, that checkpoint then contains inconsistent data. Avoiding this inconsistency is, for the time being at least, the application's responsibility.</p>
<p>See <a class="el" href="arch-transaction.html#arch-transaction-prepare">Prepared Transactions</a> for further discussion of prepared transactions. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">Reference Guide</a></li><li class="navelem"><a class="el" href="arch-index.html">WiredTiger Architecture Guide</a></li><li class="navelem"><a class="el" href="arch-toc-fundamentals.html">Fundamentals</a></li>
    <li class="footer">Copyright (c) 2008-present MongoDB, Inc.  All rights reserved.  Contact <a href="mailto:info@wiredtiger.com">info@wiredtiger.com</a> for more information.</li>
  </ul>
</div>
</body>
</html>
